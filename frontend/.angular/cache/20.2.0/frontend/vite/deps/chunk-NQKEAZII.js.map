{
  "version": 3,
  "sources": ["../../../../../../node_modules/@angular/core/fesm2022/not_found.mjs", "../../../../../../node_modules/@angular/core/fesm2022/signal.mjs", "../../../../../../node_modules/@angular/core/fesm2022/untracked.mjs", "../../../../../../node_modules/@angular/core/fesm2022/weak_ref.mjs", "../../../../../../node_modules/@angular/core/fesm2022/primitives/signals.mjs", "../../../../../../node_modules/@angular/core/fesm2022/root_effect_scheduler.mjs", "../../../../../../node_modules/@angular/core/fesm2022/resource.mjs"],
  "sourcesContent": ["/**\r\n * @license Angular v20.2.1\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\n/**\r\n * Current injector value used by `inject`.\r\n * - `undefined`: it is an error to call `inject`\r\n * - `null`: `inject` can be called but there is no injector (limp-mode).\r\n * - Injector instance: Use the injector for resolution.\r\n */\r\nlet _currentInjector = undefined;\r\nfunction getCurrentInjector() {\r\n    return _currentInjector;\r\n}\r\nfunction setCurrentInjector(injector) {\r\n    const former = _currentInjector;\r\n    _currentInjector = injector;\r\n    return former;\r\n}\r\nfunction inject(token, options) {\r\n    const currentInjector = getCurrentInjector();\r\n    if (!currentInjector) {\r\n        throw new Error('Current injector is not set.');\r\n    }\r\n    if (!token.ɵprov) {\r\n        throw new Error('Token is not an injectable');\r\n    }\r\n    return currentInjector.retrieve(token, options);\r\n}\r\n\r\n/**\r\n * Value returned if the key-value pair couldn't be found in the context\r\n * hierarchy.\r\n */\r\nconst NOT_FOUND = Symbol('NotFound');\r\n/**\r\n * Error thrown when the key-value pair couldn't be found in the context\r\n * hierarchy. Context can be attached below.\r\n */\r\nclass NotFoundError extends Error {\r\n    name = 'ɵNotFound';\r\n    constructor(message) {\r\n        super(message);\r\n    }\r\n}\r\n/**\r\n * Type guard for checking if an unknown value is a NotFound.\r\n */\r\nfunction isNotFound(e) {\r\n    return e === NOT_FOUND || e?.name === 'ɵNotFound';\r\n}\r\n\r\nexport { NOT_FOUND, NotFoundError, getCurrentInjector, inject, isNotFound, setCurrentInjector };\r\n\r\n", "/**\r\n * @license Angular v20.2.1\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\n/**\r\n * The default equality function used for `signal` and `computed`, which uses referential equality.\r\n */\r\nfunction defaultEquals(a, b) {\r\n    return Object.is(a, b);\r\n}\r\n\r\n/**\r\n * The currently active consumer `ReactiveNode`, if running code in a reactive context.\r\n *\r\n * Change this via `setActiveConsumer`.\r\n */\r\nlet activeConsumer = null;\r\nlet inNotificationPhase = false;\r\n/**\r\n * Global epoch counter. Incremented whenever a source signal is set.\r\n */\r\nlet epoch = 1;\r\n/**\r\n * If set, called after a producer `ReactiveNode` is created.\r\n */\r\nlet postProducerCreatedFn = null;\r\n/**\r\n * Symbol used to tell `Signal`s apart from other functions.\r\n *\r\n * This can be used to auto-unwrap signals in various cases, or to auto-wrap non-signal values.\r\n */\r\nconst SIGNAL = /* @__PURE__ */ Symbol('SIGNAL');\r\nfunction setActiveConsumer(consumer) {\r\n    const prev = activeConsumer;\r\n    activeConsumer = consumer;\r\n    return prev;\r\n}\r\nfunction getActiveConsumer() {\r\n    return activeConsumer;\r\n}\r\nfunction isInNotificationPhase() {\r\n    return inNotificationPhase;\r\n}\r\nfunction isReactive(value) {\r\n    return value[SIGNAL] !== undefined;\r\n}\r\nconst REACTIVE_NODE = {\r\n    version: 0,\r\n    lastCleanEpoch: 0,\r\n    dirty: false,\r\n    producers: undefined,\r\n    producersTail: undefined,\r\n    consumers: undefined,\r\n    consumersTail: undefined,\r\n    recomputing: false,\r\n    consumerAllowSignalWrites: false,\r\n    consumerIsAlwaysLive: false,\r\n    kind: 'unknown',\r\n    producerMustRecompute: () => false,\r\n    producerRecomputeValue: () => { },\r\n    consumerMarkedDirty: () => { },\r\n    consumerOnSignalRead: () => { },\r\n};\r\n/**\r\n * Called by implementations when a producer's signal is read.\r\n */\r\nfunction producerAccessed(node) {\r\n    if (inNotificationPhase) {\r\n        throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode\r\n            ? `Assertion error: signal read during notification phase`\r\n            : '');\r\n    }\r\n    if (activeConsumer === null) {\r\n        // Accessed outside of a reactive context, so nothing to record.\r\n        return;\r\n    }\r\n    activeConsumer.consumerOnSignalRead(node);\r\n    const prevProducerLink = activeConsumer.producersTail;\r\n    // If the last producer we accessed is the same as the current one, we can skip adding a new\r\n    // link\r\n    if (prevProducerLink !== undefined && prevProducerLink.producer === node) {\r\n        return;\r\n    }\r\n    let nextProducerLink = undefined;\r\n    const isRecomputing = activeConsumer.recomputing;\r\n    if (isRecomputing) {\r\n        // If we're incrementally rebuilding the producers list, we want to check if the next producer\r\n        // in the list is the same as the one we're trying to add.\r\n        // If the previous producer is defined, then the next producer is just the one that follows it.\r\n        // Otherwise, we should check the head of the producers list (the first node that we accessed the last time this consumer was run).\r\n        nextProducerLink =\r\n            prevProducerLink !== undefined ? prevProducerLink.nextProducer : activeConsumer.producers;\r\n        if (nextProducerLink !== undefined && nextProducerLink.producer === node) {\r\n            // If the next producer is the same as the one we're trying to add, we can just update the\r\n            // last read version, update the tail of the producers list of this rerun, and return.\r\n            activeConsumer.producersTail = nextProducerLink;\r\n            nextProducerLink.lastReadVersion = node.version;\r\n            return;\r\n        }\r\n    }\r\n    const prevConsumerLink = node.consumersTail;\r\n    // If the producer we're accessing already has a link to this consumer, we can skip adding a new\r\n    // link. This can short circuit the creation of a new link in the case where the consumer reads alternating ReeactiveNodes\r\n    if (prevConsumerLink !== undefined &&\r\n        prevConsumerLink.consumer === activeConsumer &&\r\n        // However, we have to make sure that the link we've discovered isn't from a node that is incrementally rebuilding its producer list\r\n        (!isRecomputing || isValidLink(prevConsumerLink, activeConsumer))) {\r\n        // If we found an existing link to the consumer we can just return.\r\n        return;\r\n    }\r\n    // If we got here, it means that we need to create a new link between the producer and the consumer.\r\n    const isLive = consumerIsLive(activeConsumer);\r\n    const newLink = {\r\n        producer: node,\r\n        consumer: activeConsumer,\r\n        // instead of eagerly destroying the previous link, we delay until we've finished recomputing\r\n        // the producers list, so that we can destroy all of the old links at once.\r\n        nextProducer: nextProducerLink,\r\n        prevConsumer: prevConsumerLink,\r\n        lastReadVersion: node.version,\r\n        nextConsumer: undefined,\r\n    };\r\n    activeConsumer.producersTail = newLink;\r\n    if (prevProducerLink !== undefined) {\r\n        prevProducerLink.nextProducer = newLink;\r\n    }\r\n    else {\r\n        activeConsumer.producers = newLink;\r\n    }\r\n    if (isLive) {\r\n        producerAddLiveConsumer(node, newLink);\r\n    }\r\n}\r\n/**\r\n * Increment the global epoch counter.\r\n *\r\n * Called by source producers (that is, not computeds) whenever their values change.\r\n */\r\nfunction producerIncrementEpoch() {\r\n    epoch++;\r\n}\r\n/**\r\n * Ensure this producer's `version` is up-to-date.\r\n */\r\nfunction producerUpdateValueVersion(node) {\r\n    if (consumerIsLive(node) && !node.dirty) {\r\n        // A live consumer will be marked dirty by producers, so a clean state means that its version\r\n        // is guaranteed to be up-to-date.\r\n        return;\r\n    }\r\n    if (!node.dirty && node.lastCleanEpoch === epoch) {\r\n        // Even non-live consumers can skip polling if they previously found themselves to be clean at\r\n        // the current epoch, since their dependencies could not possibly have changed (such a change\r\n        // would've increased the epoch).\r\n        return;\r\n    }\r\n    if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\r\n        // None of our producers report a change since the last time they were read, so no\r\n        // recomputation of our value is necessary, and we can consider ourselves clean.\r\n        producerMarkClean(node);\r\n        return;\r\n    }\r\n    node.producerRecomputeValue(node);\r\n    // After recomputing the value, we're no longer dirty.\r\n    producerMarkClean(node);\r\n}\r\n/**\r\n * Propagate a dirty notification to live consumers of this producer.\r\n */\r\nfunction producerNotifyConsumers(node) {\r\n    if (node.consumers === undefined) {\r\n        return;\r\n    }\r\n    // Prevent signal reads when we're updating the graph\r\n    const prev = inNotificationPhase;\r\n    inNotificationPhase = true;\r\n    try {\r\n        for (let link = node.consumers; link !== undefined; link = link.nextConsumer) {\r\n            const consumer = link.consumer;\r\n            if (!consumer.dirty) {\r\n                consumerMarkDirty(consumer);\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        inNotificationPhase = prev;\r\n    }\r\n}\r\n/**\r\n * Whether this `ReactiveNode` in its producer capacity is currently allowed to initiate updates,\r\n * based on the current consumer context.\r\n */\r\nfunction producerUpdatesAllowed() {\r\n    return activeConsumer?.consumerAllowSignalWrites !== false;\r\n}\r\nfunction consumerMarkDirty(node) {\r\n    node.dirty = true;\r\n    producerNotifyConsumers(node);\r\n    node.consumerMarkedDirty?.(node);\r\n}\r\nfunction producerMarkClean(node) {\r\n    node.dirty = false;\r\n    node.lastCleanEpoch = epoch;\r\n}\r\n/**\r\n * Prepare this consumer to run a computation in its reactive context.\r\n *\r\n * Must be called by subclasses which represent reactive computations, before those computations\r\n * begin.\r\n */\r\nfunction consumerBeforeComputation(node) {\r\n    if (node) {\r\n        node.producersTail = undefined;\r\n        node.recomputing = true;\r\n    }\r\n    return setActiveConsumer(node);\r\n}\r\n/**\r\n * Finalize this consumer's state after a reactive computation has run.\r\n *\r\n * Must be called by subclasses which represent reactive computations, after those computations\r\n * have finished.\r\n */\r\nfunction consumerAfterComputation(node, prevConsumer) {\r\n    setActiveConsumer(prevConsumer);\r\n    if (!node) {\r\n        return;\r\n    }\r\n    node.recomputing = false;\r\n    // We've finished incrementally rebuilding the producers list, now if there are any producers\r\n    // that are after producersTail, they are stale and should be removed.\r\n    const producersTail = node.producersTail;\r\n    let toRemove = producersTail !== undefined ? producersTail.nextProducer : node.producers;\r\n    if (toRemove !== undefined) {\r\n        if (consumerIsLive(node)) {\r\n            // For each stale link, we first unlink it from the producers list of consumers\r\n            do {\r\n                toRemove = producerRemoveLiveConsumerLink(toRemove);\r\n            } while (toRemove !== undefined);\r\n        }\r\n        // Now, we can truncate the producers list to remove all stale links.\r\n        if (producersTail !== undefined) {\r\n            producersTail.nextProducer = undefined;\r\n        }\r\n        else {\r\n            node.producers = undefined;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Determine whether this consumer has any dependencies which have changed since the last time\r\n * they were read.\r\n */\r\nfunction consumerPollProducersForChange(node) {\r\n    // Poll producers for change.\r\n    for (let link = node.producers; link !== undefined; link = link.nextProducer) {\r\n        const producer = link.producer;\r\n        const seenVersion = link.lastReadVersion;\r\n        // First check the versions. A mismatch means that the producer's value is known to have\r\n        // changed since the last time we read it.\r\n        if (seenVersion !== producer.version) {\r\n            return true;\r\n        }\r\n        // The producer's version is the same as the last time we read it, but it might itself be\r\n        // stale. Force the producer to recompute its version (calculating a new value if necessary).\r\n        producerUpdateValueVersion(producer);\r\n        // Now when we do this check, `producer.version` is guaranteed to be up to date, so if the\r\n        // versions still match then it has not changed since the last time we read it.\r\n        if (seenVersion !== producer.version) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Disconnect this consumer from the graph.\r\n */\r\nfunction consumerDestroy(node) {\r\n    if (consumerIsLive(node)) {\r\n        // Drop all connections from the graph to this node.\r\n        let link = node.producers;\r\n        while (link !== undefined) {\r\n            link = producerRemoveLiveConsumerLink(link);\r\n        }\r\n    }\r\n    // Truncate all the linked lists to drop all connection from this node to the graph.\r\n    node.producers = undefined;\r\n    node.producersTail = undefined;\r\n    node.consumers = undefined;\r\n    node.consumersTail = undefined;\r\n}\r\n/**\r\n * Add `consumer` as a live consumer of this node.\r\n *\r\n * Note that this operation is potentially transitive. If this node becomes live, then it becomes\r\n * a live consumer of all of its current producers.\r\n */\r\nfunction producerAddLiveConsumer(node, link) {\r\n    const consumersTail = node.consumersTail;\r\n    const wasLive = consumerIsLive(node);\r\n    if (consumersTail !== undefined) {\r\n        link.nextConsumer = consumersTail.nextConsumer;\r\n        consumersTail.nextConsumer = link;\r\n    }\r\n    else {\r\n        link.nextConsumer = undefined;\r\n        node.consumers = link;\r\n    }\r\n    link.prevConsumer = consumersTail;\r\n    node.consumersTail = link;\r\n    if (!wasLive) {\r\n        for (let link = node.producers; link !== undefined; link = link.nextProducer) {\r\n            producerAddLiveConsumer(link.producer, link);\r\n        }\r\n    }\r\n}\r\nfunction producerRemoveLiveConsumerLink(link) {\r\n    const producer = link.producer;\r\n    const nextProducer = link.nextProducer;\r\n    const nextConsumer = link.nextConsumer;\r\n    const prevConsumer = link.prevConsumer;\r\n    link.nextConsumer = undefined;\r\n    link.prevConsumer = undefined;\r\n    if (nextConsumer !== undefined) {\r\n        nextConsumer.prevConsumer = prevConsumer;\r\n    }\r\n    else {\r\n        producer.consumersTail = prevConsumer;\r\n    }\r\n    if (prevConsumer !== undefined) {\r\n        prevConsumer.nextConsumer = nextConsumer;\r\n    }\r\n    else {\r\n        producer.consumers = nextConsumer;\r\n        if (!consumerIsLive(producer)) {\r\n            let producerLink = producer.producers;\r\n            while (producerLink !== undefined) {\r\n                producerLink = producerRemoveLiveConsumerLink(producerLink);\r\n            }\r\n        }\r\n    }\r\n    return nextProducer;\r\n}\r\nfunction consumerIsLive(node) {\r\n    return node.consumerIsAlwaysLive || node.consumers !== undefined;\r\n}\r\nfunction runPostProducerCreatedFn(node) {\r\n    postProducerCreatedFn?.(node);\r\n}\r\nfunction setPostProducerCreatedFn(fn) {\r\n    const prev = postProducerCreatedFn;\r\n    postProducerCreatedFn = fn;\r\n    return prev;\r\n}\r\n// While a ReactiveNode is recomputing, it may not have destroyed previous links\r\n// This allows us to check if a given link will be destroyed by a reactivenode if it were to finish running immediately without accesing any more producers\r\nfunction isValidLink(checkLink, consumer) {\r\n    const producersTail = consumer.producersTail;\r\n    if (producersTail !== undefined) {\r\n        let link = consumer.producers;\r\n        do {\r\n            if (link === checkLink) {\r\n                return true;\r\n            }\r\n            if (link === producersTail) {\r\n                break;\r\n            }\r\n            link = link.nextProducer;\r\n        } while (link !== undefined);\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Create a computed signal which derives a reactive value from an expression.\r\n */\r\nfunction createComputed(computation, equal) {\r\n    const node = Object.create(COMPUTED_NODE);\r\n    node.computation = computation;\r\n    if (equal !== undefined) {\r\n        node.equal = equal;\r\n    }\r\n    const computed = () => {\r\n        // Check if the value needs updating before returning it.\r\n        producerUpdateValueVersion(node);\r\n        // Record that someone looked at this signal.\r\n        producerAccessed(node);\r\n        if (node.value === ERRORED) {\r\n            throw node.error;\r\n        }\r\n        return node.value;\r\n    };\r\n    computed[SIGNAL] = node;\r\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\r\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\r\n        computed.toString = () => `[Computed${debugName}: ${node.value}]`;\r\n    }\r\n    runPostProducerCreatedFn(node);\r\n    return computed;\r\n}\r\n/**\r\n * A dedicated symbol used before a computed value has been calculated for the first time.\r\n * Explicitly typed as `any` so we can use it as signal's value.\r\n */\r\nconst UNSET = /* @__PURE__ */ Symbol('UNSET');\r\n/**\r\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\r\n * is in progress. Used to detect cycles in computation chains.\r\n * Explicitly typed as `any` so we can use it as signal's value.\r\n */\r\nconst COMPUTING = /* @__PURE__ */ Symbol('COMPUTING');\r\n/**\r\n * A dedicated symbol used in place of a computed signal value to indicate that a given computation\r\n * failed. The thrown error is cached until the computation gets dirty again.\r\n * Explicitly typed as `any` so we can use it as signal's value.\r\n */\r\nconst ERRORED = /* @__PURE__ */ Symbol('ERRORED');\r\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\r\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\r\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\r\nconst COMPUTED_NODE = /* @__PURE__ */ (() => {\r\n    return {\r\n        ...REACTIVE_NODE,\r\n        value: UNSET,\r\n        dirty: true,\r\n        error: null,\r\n        equal: defaultEquals,\r\n        kind: 'computed',\r\n        producerMustRecompute(node) {\r\n            // Force a recomputation if there's no current value, or if the current value is in the\r\n            // process of being calculated (which should throw an error).\r\n            return node.value === UNSET || node.value === COMPUTING;\r\n        },\r\n        producerRecomputeValue(node) {\r\n            if (node.value === COMPUTING) {\r\n                // Our computation somehow led to a cyclic read of itself.\r\n                throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\r\n            }\r\n            const oldValue = node.value;\r\n            node.value = COMPUTING;\r\n            const prevConsumer = consumerBeforeComputation(node);\r\n            let newValue;\r\n            let wasEqual = false;\r\n            try {\r\n                newValue = node.computation();\r\n                // We want to mark this node as errored if calling `equal` throws; however, we don't want\r\n                // to track any reactive reads inside `equal`.\r\n                setActiveConsumer(null);\r\n                wasEqual =\r\n                    oldValue !== UNSET &&\r\n                        oldValue !== ERRORED &&\r\n                        newValue !== ERRORED &&\r\n                        node.equal(oldValue, newValue);\r\n            }\r\n            catch (err) {\r\n                newValue = ERRORED;\r\n                node.error = err;\r\n            }\r\n            finally {\r\n                consumerAfterComputation(node, prevConsumer);\r\n            }\r\n            if (wasEqual) {\r\n                // No change to `valueVersion` - old and new values are\r\n                // semantically equivalent.\r\n                node.value = oldValue;\r\n                return;\r\n            }\r\n            node.value = newValue;\r\n            node.version++;\r\n        },\r\n    };\r\n})();\r\n\r\nfunction defaultThrowError() {\r\n    throw new Error();\r\n}\r\nlet throwInvalidWriteToSignalErrorFn = defaultThrowError;\r\nfunction throwInvalidWriteToSignalError(node) {\r\n    throwInvalidWriteToSignalErrorFn(node);\r\n}\r\nfunction setThrowInvalidWriteToSignalError(fn) {\r\n    throwInvalidWriteToSignalErrorFn = fn;\r\n}\r\n\r\n/**\r\n * If set, called after `WritableSignal`s are updated.\r\n *\r\n * This hook can be used to achieve various effects, such as running effects synchronously as part\r\n * of setting a signal.\r\n */\r\nlet postSignalSetFn = null;\r\n/**\r\n * Creates a `Signal` getter, setter, and updater function.\r\n */\r\nfunction createSignal(initialValue, equal) {\r\n    const node = Object.create(SIGNAL_NODE);\r\n    node.value = initialValue;\r\n    if (equal !== undefined) {\r\n        node.equal = equal;\r\n    }\r\n    const getter = (() => signalGetFn(node));\r\n    getter[SIGNAL] = node;\r\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\r\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\r\n        getter.toString = () => `[Signal${debugName}: ${node.value}]`;\r\n    }\r\n    runPostProducerCreatedFn(node);\r\n    const set = (newValue) => signalSetFn(node, newValue);\r\n    const update = (updateFn) => signalUpdateFn(node, updateFn);\r\n    return [getter, set, update];\r\n}\r\nfunction setPostSignalSetFn(fn) {\r\n    const prev = postSignalSetFn;\r\n    postSignalSetFn = fn;\r\n    return prev;\r\n}\r\nfunction signalGetFn(node) {\r\n    producerAccessed(node);\r\n    return node.value;\r\n}\r\nfunction signalSetFn(node, newValue) {\r\n    if (!producerUpdatesAllowed()) {\r\n        throwInvalidWriteToSignalError(node);\r\n    }\r\n    if (!node.equal(node.value, newValue)) {\r\n        node.value = newValue;\r\n        signalValueChanged(node);\r\n    }\r\n}\r\nfunction signalUpdateFn(node, updater) {\r\n    if (!producerUpdatesAllowed()) {\r\n        throwInvalidWriteToSignalError(node);\r\n    }\r\n    signalSetFn(node, updater(node.value));\r\n}\r\nfunction runPostSignalSetFn(node) {\r\n    postSignalSetFn?.(node);\r\n}\r\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\r\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\r\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\r\nconst SIGNAL_NODE = /* @__PURE__ */ (() => {\r\n    return {\r\n        ...REACTIVE_NODE,\r\n        equal: defaultEquals,\r\n        value: undefined,\r\n        kind: 'signal',\r\n    };\r\n})();\r\nfunction signalValueChanged(node) {\r\n    node.version++;\r\n    producerIncrementEpoch();\r\n    producerNotifyConsumers(node);\r\n    postSignalSetFn?.(node);\r\n}\r\n\r\nexport { COMPUTING, ERRORED, REACTIVE_NODE, SIGNAL, SIGNAL_NODE, UNSET, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createComputed, createSignal, defaultEquals, getActiveConsumer, isInNotificationPhase, isReactive, producerAccessed, producerIncrementEpoch, producerMarkClean, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, runPostProducerCreatedFn, runPostSignalSetFn, setActiveConsumer, setPostProducerCreatedFn, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalGetFn, signalSetFn, signalUpdateFn };\r\n\r\n", "/**\r\n * @license Angular v20.2.1\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { SIGNAL, runPostProducerCreatedFn, producerUpdateValueVersion, signalSetFn, producerMarkClean, signalUpdateFn, REACTIVE_NODE, UNSET, defaultEquals, COMPUTING, consumerBeforeComputation, ERRORED, consumerAfterComputation, producerAccessed, setActiveConsumer } from './signal.mjs';\r\n\r\nfunction createLinkedSignal(sourceFn, computationFn, equalityFn) {\r\n    const node = Object.create(LINKED_SIGNAL_NODE);\r\n    node.source = sourceFn;\r\n    node.computation = computationFn;\r\n    if (equalityFn != undefined) {\r\n        node.equal = equalityFn;\r\n    }\r\n    const linkedSignalGetter = () => {\r\n        // Check if the value needs updating before returning it.\r\n        producerUpdateValueVersion(node);\r\n        // Record that someone looked at this signal.\r\n        producerAccessed(node);\r\n        if (node.value === ERRORED) {\r\n            throw node.error;\r\n        }\r\n        return node.value;\r\n    };\r\n    const getter = linkedSignalGetter;\r\n    getter[SIGNAL] = node;\r\n    if (typeof ngDevMode !== 'undefined' && ngDevMode) {\r\n        const debugName = node.debugName ? ' (' + node.debugName + ')' : '';\r\n        getter.toString = () => `[LinkedSignal${debugName}: ${node.value}]`;\r\n    }\r\n    runPostProducerCreatedFn(node);\r\n    return getter;\r\n}\r\nfunction linkedSignalSetFn(node, newValue) {\r\n    producerUpdateValueVersion(node);\r\n    signalSetFn(node, newValue);\r\n    producerMarkClean(node);\r\n}\r\nfunction linkedSignalUpdateFn(node, updater) {\r\n    producerUpdateValueVersion(node);\r\n    signalUpdateFn(node, updater);\r\n    producerMarkClean(node);\r\n}\r\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\r\n// a side-effect, ending up preserving `LINKED_SIGNAL_NODE` and `REACTIVE_NODE`.\r\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\r\nconst LINKED_SIGNAL_NODE = /* @__PURE__ */ (() => {\r\n    return {\r\n        ...REACTIVE_NODE,\r\n        value: UNSET,\r\n        dirty: true,\r\n        error: null,\r\n        equal: defaultEquals,\r\n        kind: 'linkedSignal',\r\n        producerMustRecompute(node) {\r\n            // Force a recomputation if there's no current value, or if the current value is in the\r\n            // process of being calculated (which should throw an error).\r\n            return node.value === UNSET || node.value === COMPUTING;\r\n        },\r\n        producerRecomputeValue(node) {\r\n            if (node.value === COMPUTING) {\r\n                // Our computation somehow led to a cyclic read of itself.\r\n                throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode ? 'Detected cycle in computations.' : '');\r\n            }\r\n            const oldValue = node.value;\r\n            node.value = COMPUTING;\r\n            const prevConsumer = consumerBeforeComputation(node);\r\n            let newValue;\r\n            try {\r\n                const newSourceValue = node.source();\r\n                const prev = oldValue === UNSET || oldValue === ERRORED\r\n                    ? undefined\r\n                    : {\r\n                        source: node.sourceValue,\r\n                        value: oldValue,\r\n                    };\r\n                newValue = node.computation(newSourceValue, prev);\r\n                node.sourceValue = newSourceValue;\r\n            }\r\n            catch (err) {\r\n                newValue = ERRORED;\r\n                node.error = err;\r\n            }\r\n            finally {\r\n                consumerAfterComputation(node, prevConsumer);\r\n            }\r\n            if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {\r\n                // No change to `valueVersion` - old and new values are\r\n                // semantically equivalent.\r\n                node.value = oldValue;\r\n                return;\r\n            }\r\n            node.value = newValue;\r\n            node.version++;\r\n        },\r\n    };\r\n})();\r\n\r\n/**\r\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\r\n * can, optionally, return a value.\r\n */\r\nfunction untracked(nonReactiveReadsFn) {\r\n    const prevConsumer = setActiveConsumer(null);\r\n    // We are not trying to catch any particular errors here, just making sure that the consumers\r\n    // stack is restored in case of errors.\r\n    try {\r\n        return nonReactiveReadsFn();\r\n    }\r\n    finally {\r\n        setActiveConsumer(prevConsumer);\r\n    }\r\n}\r\n\r\nexport { createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn, untracked };\r\n\r\n", "/**\r\n * @license Angular v20.2.1\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nfunction setAlternateWeakRefImpl(impl) {\r\n    // TODO: remove this function\r\n}\r\n\r\nexport { setAlternateWeakRefImpl };\r\n\r\n", "/**\r\n * @license Angular v20.2.1\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { consumerMarkDirty, SIGNAL, REACTIVE_NODE, consumerDestroy, isInNotificationPhase, consumerPollProducersForChange, consumerBeforeComputation, consumerAfterComputation } from '../signal.mjs';\r\nexport { SIGNAL_NODE, createComputed, createSignal, defaultEquals, getActiveConsumer, isReactive, producerAccessed, producerIncrementEpoch, producerMarkClean, producerNotifyConsumers, producerUpdateValueVersion, producerUpdatesAllowed, runPostProducerCreatedFn, runPostSignalSetFn, setActiveConsumer, setPostProducerCreatedFn, setPostSignalSetFn, setThrowInvalidWriteToSignalError, signalGetFn, signalSetFn, signalUpdateFn } from '../signal.mjs';\r\nexport { createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn, untracked } from '../untracked.mjs';\r\nexport { setAlternateWeakRefImpl } from '../weak_ref.mjs';\r\n\r\nfunction createWatch(fn, schedule, allowSignalWrites) {\r\n    const node = Object.create(WATCH_NODE);\r\n    if (allowSignalWrites) {\r\n        node.consumerAllowSignalWrites = true;\r\n    }\r\n    node.fn = fn;\r\n    node.schedule = schedule;\r\n    const registerOnCleanup = (cleanupFn) => {\r\n        node.cleanupFn = cleanupFn;\r\n    };\r\n    function isWatchNodeDestroyed(node) {\r\n        return node.fn === null && node.schedule === null;\r\n    }\r\n    function destroyWatchNode(node) {\r\n        if (!isWatchNodeDestroyed(node)) {\r\n            consumerDestroy(node); // disconnect watcher from the reactive graph\r\n            node.cleanupFn();\r\n            // nullify references to the integration functions to mark node as destroyed\r\n            node.fn = null;\r\n            node.schedule = null;\r\n            node.cleanupFn = NOOP_CLEANUP_FN;\r\n        }\r\n    }\r\n    const run = () => {\r\n        if (node.fn === null) {\r\n            // trying to run a destroyed watch is noop\r\n            return;\r\n        }\r\n        if (isInNotificationPhase()) {\r\n            throw new Error(typeof ngDevMode !== 'undefined' && ngDevMode\r\n                ? 'Schedulers cannot synchronously execute watches while scheduling.'\r\n                : '');\r\n        }\r\n        node.dirty = false;\r\n        if (node.hasRun && !consumerPollProducersForChange(node)) {\r\n            return;\r\n        }\r\n        node.hasRun = true;\r\n        const prevConsumer = consumerBeforeComputation(node);\r\n        try {\r\n            node.cleanupFn();\r\n            node.cleanupFn = NOOP_CLEANUP_FN;\r\n            node.fn(registerOnCleanup);\r\n        }\r\n        finally {\r\n            consumerAfterComputation(node, prevConsumer);\r\n        }\r\n    };\r\n    node.ref = {\r\n        notify: () => consumerMarkDirty(node),\r\n        run,\r\n        cleanup: () => node.cleanupFn(),\r\n        destroy: () => destroyWatchNode(node),\r\n        [SIGNAL]: node,\r\n    };\r\n    return node.ref;\r\n}\r\nconst NOOP_CLEANUP_FN = () => { };\r\n// Note: Using an IIFE here to ensure that the spread assignment is not considered\r\n// a side-effect, ending up preserving `COMPUTED_NODE` and `REACTIVE_NODE`.\r\n// TODO: remove when https://github.com/evanw/esbuild/issues/3392 is resolved.\r\nconst WATCH_NODE = /* @__PURE__ */ (() => {\r\n    return {\r\n        ...REACTIVE_NODE,\r\n        consumerIsAlwaysLive: true,\r\n        consumerAllowSignalWrites: false,\r\n        consumerMarkedDirty: (node) => {\r\n            if (node.schedule !== null) {\r\n                node.schedule(node.ref);\r\n            }\r\n        },\r\n        hasRun: false,\r\n        cleanupFn: NOOP_CLEANUP_FN,\r\n    };\r\n})();\r\n\r\nexport { REACTIVE_NODE, SIGNAL, consumerAfterComputation, consumerBeforeComputation, consumerDestroy, consumerMarkDirty, consumerPollProducersForChange, createWatch, isInNotificationPhase };\r\n\r\n", "/**\r\n * @license Angular v20.2.1\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { isNotFound, getCurrentInjector, setCurrentInjector } from './not_found.mjs';\r\nimport { getActiveConsumer, SIGNAL, createSignal } from './signal.mjs';\r\nimport { BehaviorSubject, Observable } from 'rxjs';\r\nimport { setActiveConsumer } from '@angular/core/primitives/signals';\r\nimport { isNotFound as isNotFound$1 } from '@angular/core/primitives/di';\r\n\r\n/**\r\n * Base URL for the error details page.\r\n *\r\n * Keep this constant in sync across:\r\n *  - packages/compiler-cli/src/ngtsc/diagnostics/src/error_details_base_url.ts\r\n *  - packages/core/src/error_details_base_url.ts\r\n */\r\nconst ERROR_DETAILS_PAGE_BASE_URL = 'https://angular.dev/errors';\r\n/**\r\n * URL for the XSS security documentation.\r\n */\r\nconst XSS_SECURITY_URL = 'https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss';\r\n\r\n/**\r\n * Class that represents a runtime error.\r\n * Formats and outputs the error message in a consistent way.\r\n *\r\n * Example:\r\n * ```ts\r\n *  throw new RuntimeError(\r\n *    RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED,\r\n *    ngDevMode && 'Injector has already been destroyed.');\r\n * ```\r\n *\r\n * Note: the `message` argument contains a descriptive error message as a string in development\r\n * mode (when the `ngDevMode` is defined). In production mode (after tree-shaking pass), the\r\n * `message` argument becomes `false`, thus we account for it in the typings and the runtime\r\n * logic.\r\n */\r\nclass RuntimeError extends Error {\r\n    code;\r\n    constructor(code, message) {\r\n        super(formatRuntimeError(code, message));\r\n        this.code = code;\r\n    }\r\n}\r\nfunction formatRuntimeErrorCode(code) {\r\n    // Error code might be a negative number, which is a special marker that instructs the logic to\r\n    // generate a link to the error details page on angular.io.\r\n    // We also prepend `0` to non-compile-time errors.\r\n    return `NG0${Math.abs(code)}`;\r\n}\r\n/**\r\n * Called to format a runtime error.\r\n * See additional info on the `message` argument type in the `RuntimeError` class description.\r\n */\r\nfunction formatRuntimeError(code, message) {\r\n    const fullCode = formatRuntimeErrorCode(code);\r\n    let errorMessage = `${fullCode}${message ? ': ' + message : ''}`;\r\n    if (ngDevMode && code < 0) {\r\n        const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\r\n        const separator = addPeriodSeparator ? '.' : '';\r\n        errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\r\n    }\r\n    return errorMessage;\r\n}\r\n\r\nconst _global = globalThis;\r\n\r\nfunction ngDevModeResetPerfCounters() {\r\n    const locationString = typeof location !== 'undefined' ? location.toString() : '';\r\n    const newCounters = {\r\n        hydratedNodes: 0,\r\n        hydratedComponents: 0,\r\n        dehydratedViewsRemoved: 0,\r\n        dehydratedViewsCleanupRuns: 0,\r\n        componentsSkippedHydration: 0,\r\n        deferBlocksWithIncrementalHydration: 0,\r\n    };\r\n    // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\r\n    const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\r\n    if (!allowNgDevModeTrue) {\r\n        _global['ngDevMode'] = false;\r\n    }\r\n    else {\r\n        if (typeof _global['ngDevMode'] !== 'object') {\r\n            _global['ngDevMode'] = {};\r\n        }\r\n        Object.assign(_global['ngDevMode'], newCounters);\r\n    }\r\n    return newCounters;\r\n}\r\n/**\r\n * This function checks to see if the `ngDevMode` has been set. If yes,\r\n * then we honor it, otherwise we default to dev mode with additional checks.\r\n *\r\n * The idea is that unless we are doing production build where we explicitly\r\n * set `ngDevMode == false` we should be helping the developer by providing\r\n * as much early warning and errors as possible.\r\n *\r\n * `ɵɵdefineComponent` is guaranteed to have been called before any component template functions\r\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\r\n * is defined for the entire instruction set.\r\n *\r\n * When checking `ngDevMode` on toplevel, always init it before referencing it\r\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\r\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\r\n *\r\n * Details on possible values for `ngDevMode` can be found on its docstring.\r\n */\r\nfunction initNgDevMode() {\r\n    // The below checks are to ensure that calling `initNgDevMode` multiple times does not\r\n    // reset the counters.\r\n    // If the `ngDevMode` is not an object, then it means we have not created the perf counters\r\n    // yet.\r\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\r\n        if (typeof ngDevMode !== 'object' || Object.keys(ngDevMode).length === 0) {\r\n            ngDevModeResetPerfCounters();\r\n        }\r\n        return typeof ngDevMode !== 'undefined' && !!ngDevMode;\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction getClosureSafeProperty(objWithPropertyToExtract) {\r\n    for (let key in objWithPropertyToExtract) {\r\n        if (objWithPropertyToExtract[key] === getClosureSafeProperty) {\r\n            return key;\r\n        }\r\n    }\r\n    // Cannot change it to `RuntimeError` because the `util` target cannot\r\n    // circularly depend on the `core` target.\r\n    throw Error(typeof ngDevMode !== 'undefined' && ngDevMode\r\n        ? 'Could not find renamed property on target object.'\r\n        : '');\r\n}\r\n/**\r\n * Sets properties on a target object from a source object, but only if\r\n * the property doesn't already exist on the target object.\r\n * @param target The target to set properties on\r\n * @param source The source of the property keys and values to set\r\n */\r\nfunction fillProperties(target, source) {\r\n    for (const key in source) {\r\n        if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\r\n            target[key] = source[key];\r\n        }\r\n    }\r\n}\r\n\r\nfunction stringify(token) {\r\n    if (typeof token === 'string') {\r\n        return token;\r\n    }\r\n    if (Array.isArray(token)) {\r\n        return `[${token.map(stringify).join(', ')}]`;\r\n    }\r\n    if (token == null) {\r\n        return '' + token;\r\n    }\r\n    const name = token.overriddenName || token.name;\r\n    if (name) {\r\n        return `${name}`;\r\n    }\r\n    const result = token.toString();\r\n    if (result == null) {\r\n        return '' + result;\r\n    }\r\n    const newLineIndex = result.indexOf('\\n');\r\n    return newLineIndex >= 0 ? result.slice(0, newLineIndex) : result;\r\n}\r\n/**\r\n * Concatenates two strings with separator, allocating new strings only when necessary.\r\n *\r\n * @param before before string.\r\n * @param separator separator string.\r\n * @param after after string.\r\n * @returns concatenated string.\r\n */\r\nfunction concatStringsWithSpace(before, after) {\r\n    if (!before)\r\n        return after || '';\r\n    if (!after)\r\n        return before;\r\n    return `${before} ${after}`;\r\n}\r\n/**\r\n * Ellipses the string in the middle when longer than the max length\r\n *\r\n * @param string\r\n * @param maxLength of the output string\r\n * @returns ellipsed string with ... in the middle\r\n */\r\nfunction truncateMiddle(str, maxLength = 100) {\r\n    if (!str || maxLength < 1 || str.length <= maxLength)\r\n        return str;\r\n    if (maxLength == 1)\r\n        return str.substring(0, 1) + '...';\r\n    const halfLimit = Math.round(maxLength / 2);\r\n    return str.substring(0, halfLimit) + '...' + str.substring(str.length - halfLimit);\r\n}\r\n\r\nconst __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });\r\n/**\r\n * Allows to refer to references which are not yet defined.\r\n *\r\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\r\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\r\n * a query is not yet defined.\r\n *\r\n * `forwardRef` is also used to break circularities in standalone components imports.\r\n *\r\n * @usageNotes\r\n * ### Circular dependency example\r\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\r\n *\r\n * ### Circular standalone reference import example\r\n * ```angular-ts\r\n * @Component({\r\n *   imports: [ChildComponent],\r\n *   selector: 'app-parent',\r\n *   template: `<app-child [hideParent]=\"hideParent()\"></app-child>`,\r\n * })\r\n * export class ParentComponent {\r\n *    hideParent = input.required<boolean>();\r\n * }\r\n *\r\n *\r\n * @Component({\r\n *   imports: [forwardRef(() => ParentComponent)],\r\n *   selector: 'app-child',\r\n *   template: `\r\n *    @if(!hideParent() {\r\n *       <app-parent/>\r\n *    }\r\n *  `,\r\n * })\r\n * export class ChildComponent {\r\n *    hideParent = input.required<boolean>();\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nfunction forwardRef(forwardRefFn) {\r\n    forwardRefFn.__forward_ref__ = forwardRef;\r\n    forwardRefFn.toString = function () {\r\n        return stringify(this());\r\n    };\r\n    return forwardRefFn;\r\n}\r\n/**\r\n * Lazily retrieves the reference value from a forwardRef.\r\n *\r\n * Acts as the identity function when given a non-forward-ref value.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\r\n *\r\n * @see {@link forwardRef}\r\n * @publicApi\r\n */\r\nfunction resolveForwardRef(type) {\r\n    return isForwardRef(type) ? type() : type;\r\n}\r\n/** Checks whether a function is wrapped by a `forwardRef`. */\r\nfunction isForwardRef(fn) {\r\n    return (typeof fn === 'function' &&\r\n        fn.hasOwnProperty(__forward_ref__) &&\r\n        fn.__forward_ref__ === forwardRef);\r\n}\r\n\r\n// The functions in this file verify that the assumptions we are making\r\n// about state in an instruction are correct before implementing any logic.\r\n// They are meant only to be called in dev mode as sanity checks.\r\nfunction assertNumber(actual, msg) {\r\n    if (!(typeof actual === 'number')) {\r\n        throwError(msg, typeof actual, 'number', '===');\r\n    }\r\n}\r\nfunction assertNumberInRange(actual, minInclusive, maxInclusive) {\r\n    assertNumber(actual, 'Expected a number');\r\n    assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');\r\n    assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');\r\n}\r\nfunction assertString(actual, msg) {\r\n    if (!(typeof actual === 'string')) {\r\n        throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');\r\n    }\r\n}\r\nfunction assertFunction(actual, msg) {\r\n    if (!(typeof actual === 'function')) {\r\n        throwError(msg, actual === null ? 'null' : typeof actual, 'function', '===');\r\n    }\r\n}\r\nfunction assertEqual(actual, expected, msg) {\r\n    if (!(actual == expected)) {\r\n        throwError(msg, actual, expected, '==');\r\n    }\r\n}\r\nfunction assertNotEqual(actual, expected, msg) {\r\n    if (!(actual != expected)) {\r\n        throwError(msg, actual, expected, '!=');\r\n    }\r\n}\r\nfunction assertSame(actual, expected, msg) {\r\n    if (!(actual === expected)) {\r\n        throwError(msg, actual, expected, '===');\r\n    }\r\n}\r\nfunction assertNotSame(actual, expected, msg) {\r\n    if (!(actual !== expected)) {\r\n        throwError(msg, actual, expected, '!==');\r\n    }\r\n}\r\nfunction assertLessThan(actual, expected, msg) {\r\n    if (!(actual < expected)) {\r\n        throwError(msg, actual, expected, '<');\r\n    }\r\n}\r\nfunction assertLessThanOrEqual(actual, expected, msg) {\r\n    if (!(actual <= expected)) {\r\n        throwError(msg, actual, expected, '<=');\r\n    }\r\n}\r\nfunction assertGreaterThan(actual, expected, msg) {\r\n    if (!(actual > expected)) {\r\n        throwError(msg, actual, expected, '>');\r\n    }\r\n}\r\nfunction assertGreaterThanOrEqual(actual, expected, msg) {\r\n    if (!(actual >= expected)) {\r\n        throwError(msg, actual, expected, '>=');\r\n    }\r\n}\r\nfunction assertNotDefined(actual, msg) {\r\n    if (actual != null) {\r\n        throwError(msg, actual, null, '==');\r\n    }\r\n}\r\nfunction assertDefined(actual, msg) {\r\n    if (actual == null) {\r\n        throwError(msg, actual, null, '!=');\r\n    }\r\n}\r\nfunction throwError(msg, actual, expected, comparison) {\r\n    throw new Error(`ASSERTION ERROR: ${msg}` +\r\n        (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));\r\n}\r\nfunction assertDomNode(node) {\r\n    if (!(node instanceof Node)) {\r\n        throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\r\n    }\r\n}\r\nfunction assertElement(node) {\r\n    if (!(node instanceof Element)) {\r\n        throwError(`The provided value must be an element but got ${stringify(node)}`);\r\n    }\r\n}\r\nfunction assertIndexInRange(arr, index) {\r\n    assertDefined(arr, 'Array must be defined.');\r\n    const maxLen = arr.length;\r\n    if (index < 0 || index >= maxLen) {\r\n        throwError(`Index expected to be less than ${maxLen} but got ${index}`);\r\n    }\r\n}\r\nfunction assertOneOf(value, ...validValues) {\r\n    if (validValues.indexOf(value) !== -1)\r\n        return true;\r\n    throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);\r\n}\r\nfunction assertNotReactive(fn) {\r\n    if (getActiveConsumer() !== null) {\r\n        throwError(`${fn}() should never be called in a reactive context.`);\r\n    }\r\n}\r\n\r\n/**\r\n * Construct an injectable definition which defines how a token will be constructed by the DI\r\n * system, and in which injectors (if any) it will be available.\r\n *\r\n * This should be assigned to a static `ɵprov` field on a type, which will then be an\r\n * `InjectableType`.\r\n *\r\n * Options:\r\n * * `providedIn` determines which injectors will include the injectable, by either associating it\r\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\r\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\r\n * * `factory` gives the zero argument function which will create an instance of the injectable.\r\n *   The factory can call [`inject`](api/core/inject) to access the `Injector` and request injection\r\n * of dependencies.\r\n *\r\n * @codeGenApi\r\n * @publicApi This instruction has been emitted by ViewEngine for some time and is deployed to npm.\r\n */\r\nfunction ɵɵdefineInjectable(opts) {\r\n    return {\r\n        token: opts.token,\r\n        providedIn: opts.providedIn || null,\r\n        factory: opts.factory,\r\n        value: undefined,\r\n    };\r\n}\r\n/**\r\n * @deprecated in v8, delete after v10. This API should be used only by generated code, and that\r\n * code should now use ɵɵdefineInjectable instead.\r\n * @publicApi\r\n */\r\nconst defineInjectable = ɵɵdefineInjectable;\r\n/**\r\n * Construct an `InjectorDef` which configures an injector.\r\n *\r\n * This should be assigned to a static injector def (`ɵinj`) field on a type, which will then be an\r\n * `InjectorType`.\r\n *\r\n * Options:\r\n *\r\n * * `providers`: an optional array of providers to add to the injector. Each provider must\r\n *   either have a factory or point to a type which has a `ɵprov` static property (the\r\n *   type must be an `InjectableType`).\r\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\r\n *   whose providers will also be added to the injector. Locally provided types will override\r\n *   providers from imports.\r\n *\r\n * @codeGenApi\r\n */\r\nfunction ɵɵdefineInjector(options) {\r\n    return { providers: options.providers || [], imports: options.imports || [] };\r\n}\r\n/**\r\n * Read the injectable def (`ɵprov`) for `type` in a way which is immune to accidentally reading\r\n * inherited value.\r\n *\r\n * @param type A type which may have its own (non-inherited) `ɵprov`.\r\n */\r\nfunction getInjectableDef(type) {\r\n    return getOwnDefinition(type, NG_PROV_DEF);\r\n}\r\nfunction isInjectable(type) {\r\n    return getInjectableDef(type) !== null;\r\n}\r\n/**\r\n * Return definition only if it is defined directly on `type` and is not inherited from a base\r\n * class of `type`.\r\n */\r\nfunction getOwnDefinition(type, field) {\r\n    // if the ɵprov prop exist but is undefined we still want to return null\r\n    return (type.hasOwnProperty(field) && type[field]) || null;\r\n}\r\n/**\r\n * Read the injectable def (`ɵprov`) for `type` or read the `ɵprov` from one of its ancestors.\r\n *\r\n * @param type A type which may have `ɵprov`, via inheritance.\r\n *\r\n * @deprecated Will be removed in a future version of Angular, where an error will occur in the\r\n *     scenario if we find the `ɵprov` on an ancestor only.\r\n */\r\nfunction getInheritedInjectableDef(type) {\r\n    // if the ɵprov prop exist but is undefined we still want to return null\r\n    const def = type?.[NG_PROV_DEF] ?? null;\r\n    if (def) {\r\n        ngDevMode &&\r\n            console.warn(`DEPRECATED: DI is instantiating a token \"${type.name}\" that inherits its @Injectable decorator but does not provide one itself.\\n` +\r\n                `This will become an error in a future version of Angular. Please add @Injectable() to the \"${type.name}\" class.`);\r\n        return def;\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\n/**\r\n * Read the injector def type in a way which is immune to accidentally reading inherited value.\r\n *\r\n * @param type type which may have an injector def (`ɵinj`)\r\n */\r\nfunction getInjectorDef(type) {\r\n    return type && type.hasOwnProperty(NG_INJ_DEF) ? type[NG_INJ_DEF] : null;\r\n}\r\nconst NG_PROV_DEF = getClosureSafeProperty({ ɵprov: getClosureSafeProperty });\r\nconst NG_INJ_DEF = getClosureSafeProperty({ ɵinj: getClosureSafeProperty });\r\n\r\n/**\r\n * Creates a token that can be used in a DI Provider.\r\n *\r\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\r\n * runtime representation) such as when injecting an interface, callable type, array or\r\n * parameterized type.\r\n *\r\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\r\n * the `Injector`. This provides an additional level of type safety.\r\n *\r\n * <div class=\"docs-alert docs-alert-helpful\">\r\n *\r\n * **Important Note**: Ensure that you use the same instance of the `InjectionToken` in both the\r\n * provider and the injection call. Creating a new instance of `InjectionToken` in different places,\r\n * even with the same description, will be treated as different tokens by Angular's DI system,\r\n * leading to a `NullInjectorError`.\r\n *\r\n * </div>\r\n *\r\n * {@example injection-token/src/main.ts region='InjectionToken'}\r\n *\r\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\r\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\r\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\r\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\r\n * dependencies, it can do so using the [`inject`](api/core/inject) function.\r\n * As you can see in the Tree-shakable InjectionToken example below.\r\n *\r\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\r\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule` (note:\r\n * this option is now deprecated). As mentioned above, `'root'` is the default value for\r\n * `providedIn`.\r\n *\r\n * The `providedIn: NgModule` and `providedIn: 'any'` options are deprecated.\r\n *\r\n * @usageNotes\r\n * ### Basic Examples\r\n *\r\n * ### Plain InjectionToken\r\n *\r\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\r\n *\r\n * ### Tree-shakable InjectionToken\r\n *\r\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\r\n *\r\n * @publicApi\r\n */\r\nclass InjectionToken {\r\n    _desc;\r\n    /** @internal */\r\n    ngMetadataName = 'InjectionToken';\r\n    ɵprov;\r\n    /**\r\n     * @param _desc   Description for the token,\r\n     *                used only for debugging purposes,\r\n     *                it should but does not need to be unique\r\n     * @param options Options for the token's usage, as described above\r\n     */\r\n    constructor(_desc, options) {\r\n        this._desc = _desc;\r\n        this.ɵprov = undefined;\r\n        if (typeof options == 'number') {\r\n            (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n                assertLessThan(options, 0, 'Only negative numbers are supported here');\r\n            // This is a special hack to assign __NG_ELEMENT_ID__ to this instance.\r\n            // See `InjectorMarkers`\r\n            this.__NG_ELEMENT_ID__ = options;\r\n        }\r\n        else if (options !== undefined) {\r\n            this.ɵprov = ɵɵdefineInjectable({\r\n                token: this,\r\n                providedIn: options.providedIn || 'root',\r\n                factory: options.factory,\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    get multi() {\r\n        return this;\r\n    }\r\n    toString() {\r\n        return `InjectionToken ${this._desc}`;\r\n    }\r\n}\r\n\r\nlet _injectorProfilerContext;\r\nfunction getInjectorProfilerContext() {\r\n    !ngDevMode && throwError('getInjectorProfilerContext should never be called in production mode');\r\n    return _injectorProfilerContext;\r\n}\r\nfunction setInjectorProfilerContext(context) {\r\n    !ngDevMode && throwError('setInjectorProfilerContext should never be called in production mode');\r\n    const previous = _injectorProfilerContext;\r\n    _injectorProfilerContext = context;\r\n    return previous;\r\n}\r\nconst injectorProfilerCallbacks = [];\r\nconst NOOP_PROFILER_REMOVAL = () => { };\r\nfunction removeProfiler(profiler) {\r\n    const profilerIdx = injectorProfilerCallbacks.indexOf(profiler);\r\n    if (profilerIdx !== -1) {\r\n        injectorProfilerCallbacks.splice(profilerIdx, 1);\r\n    }\r\n}\r\n/**\r\n * Adds a callback function which will be invoked during certain DI events within the\r\n * runtime (for example: injecting services, creating injectable instances, configuring providers).\r\n * Multiple profiler callbacks can be set: in this case profiling events are\r\n * reported to every registered callback.\r\n *\r\n * Warning: this function is *INTERNAL* and should not be relied upon in application's code.\r\n * The contract of the function might be changed in any release and/or the function can be removed\r\n * completely.\r\n *\r\n * @param profiler function provided by the caller or null value to disable profiling.\r\n * @returns a cleanup function that, when invoked, removes a given profiler callback.\r\n */\r\nfunction setInjectorProfiler(injectorProfiler) {\r\n    !ngDevMode && throwError('setInjectorProfiler should never be called in production mode');\r\n    if (injectorProfiler !== null) {\r\n        if (!injectorProfilerCallbacks.includes(injectorProfiler)) {\r\n            injectorProfilerCallbacks.push(injectorProfiler);\r\n        }\r\n        return () => removeProfiler(injectorProfiler);\r\n    }\r\n    else {\r\n        injectorProfilerCallbacks.length = 0;\r\n        return NOOP_PROFILER_REMOVAL;\r\n    }\r\n}\r\n/**\r\n * Injector profiler function which emits on DI events executed by the runtime.\r\n *\r\n * @param event InjectorProfilerEvent corresponding to the DI event being emitted\r\n */\r\nfunction injectorProfiler(event) {\r\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\r\n    for (let i = 0; i < injectorProfilerCallbacks.length; i++) {\r\n        const injectorProfilerCallback = injectorProfilerCallbacks[i];\r\n        injectorProfilerCallback(event);\r\n    }\r\n}\r\n/**\r\n * Emits an InjectorProfilerEventType.ProviderConfigured to the injector profiler. The data in the\r\n * emitted event includes the raw provider, as well as the token that provider is providing.\r\n *\r\n * @param eventProvider A provider object\r\n */\r\nfunction emitProviderConfiguredEvent(eventProvider, isViewProvider = false) {\r\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\r\n    let token;\r\n    // if the provider is a TypeProvider (typeof provider is function) then the token is the\r\n    // provider itself\r\n    if (typeof eventProvider === 'function') {\r\n        token = eventProvider;\r\n    }\r\n    // if the provider is an injection token, then the token is the injection token.\r\n    else if (eventProvider instanceof InjectionToken) {\r\n        token = eventProvider;\r\n    }\r\n    // in all other cases we can access the token via the `provide` property of the provider\r\n    else {\r\n        token = resolveForwardRef(eventProvider.provide);\r\n    }\r\n    let provider = eventProvider;\r\n    // Injection tokens may define their own default provider which gets attached to the token itself\r\n    // as `ɵprov`. In this case, we want to emit the provider that is attached to the token, not the\r\n    // token itself.\r\n    if (eventProvider instanceof InjectionToken) {\r\n        provider = eventProvider.ɵprov || eventProvider;\r\n    }\r\n    injectorProfiler({\r\n        type: 2 /* InjectorProfilerEventType.ProviderConfigured */,\r\n        context: getInjectorProfilerContext(),\r\n        providerRecord: { token, provider, isViewProvider },\r\n    });\r\n}\r\n/**\r\n * Emits an event to the injector profiler when an instance corresponding to a given token is about to be created be an injector. Note that\r\n * the injector associated with this emission can be accessed by using getDebugInjectContext()\r\n *\r\n * @param instance an object created by an injector\r\n */\r\nfunction emitInjectorToCreateInstanceEvent(token) {\r\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\r\n    injectorProfiler({\r\n        type: 4 /* InjectorProfilerEventType.InjectorToCreateInstanceEvent */,\r\n        context: getInjectorProfilerContext(),\r\n        token: token,\r\n    });\r\n}\r\n/**\r\n * Emits an event to the injector profiler with the instance that was created. Note that\r\n * the injector associated with this emission can be accessed by using getDebugInjectContext()\r\n *\r\n * @param instance an object created by an injector\r\n */\r\nfunction emitInstanceCreatedByInjectorEvent(instance) {\r\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\r\n    injectorProfiler({\r\n        type: 1 /* InjectorProfilerEventType.InstanceCreatedByInjector */,\r\n        context: getInjectorProfilerContext(),\r\n        instance: { value: instance },\r\n    });\r\n}\r\n/**\r\n * @param token DI token associated with injected service\r\n * @param value the instance of the injected service (i.e the result of `inject(token)`)\r\n * @param flags the flags that the token was injected with\r\n */\r\nfunction emitInjectEvent(token, value, flags) {\r\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\r\n    injectorProfiler({\r\n        type: 0 /* InjectorProfilerEventType.Inject */,\r\n        context: getInjectorProfilerContext(),\r\n        service: { token, value, flags },\r\n    });\r\n}\r\nfunction emitEffectCreatedEvent(effect) {\r\n    !ngDevMode && throwError('Injector profiler should never be called in production mode');\r\n    injectorProfiler({\r\n        type: 3 /* InjectorProfilerEventType.EffectCreated */,\r\n        context: getInjectorProfilerContext(),\r\n        effect,\r\n    });\r\n}\r\nfunction runInInjectorProfilerContext(injector, token, callback) {\r\n    !ngDevMode &&\r\n        throwError('runInInjectorProfilerContext should never be called in production mode');\r\n    const prevInjectContext = setInjectorProfilerContext({ injector, token });\r\n    try {\r\n        callback();\r\n    }\r\n    finally {\r\n        setInjectorProfilerContext(prevInjectContext);\r\n    }\r\n}\r\n\r\nfunction isEnvironmentProviders(value) {\r\n    return value && !!value.ɵproviders;\r\n}\r\n\r\nconst NG_COMP_DEF = getClosureSafeProperty({ ɵcmp: getClosureSafeProperty });\r\nconst NG_DIR_DEF = getClosureSafeProperty({ ɵdir: getClosureSafeProperty });\r\nconst NG_PIPE_DEF = getClosureSafeProperty({ ɵpipe: getClosureSafeProperty });\r\nconst NG_MOD_DEF = getClosureSafeProperty({ ɵmod: getClosureSafeProperty });\r\nconst NG_FACTORY_DEF = getClosureSafeProperty({ ɵfac: getClosureSafeProperty });\r\n/**\r\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\r\n * the key and the directive's unique ID as the value. This allows us to map directives to their\r\n * bloom filter bit for DI.\r\n */\r\n// TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.\r\nconst NG_ELEMENT_ID = getClosureSafeProperty({\r\n    __NG_ELEMENT_ID__: getClosureSafeProperty,\r\n});\r\n/**\r\n * The `NG_ENV_ID` field on a DI token indicates special processing in the `EnvironmentInjector`:\r\n * getting such tokens from the `EnvironmentInjector` will bypass the standard DI resolution\r\n * strategy and instead will return implementation produced by the `NG_ENV_ID` factory function.\r\n *\r\n * This particular retrieval of DI tokens is mostly done to eliminate circular dependencies and\r\n * improve tree-shaking.\r\n */\r\nconst NG_ENV_ID = getClosureSafeProperty({ __NG_ENV_ID__: getClosureSafeProperty });\r\n\r\n/**\r\n * Used for stringify render output in Ivy.\r\n * Important! This function is very performance-sensitive and we should\r\n * be extra careful not to introduce megamorphic reads in it.\r\n * Check `core/test/render3/perf/render_stringify` for benchmarks and alternate implementations.\r\n */\r\nfunction renderStringify(value) {\r\n    if (typeof value === 'string')\r\n        return value;\r\n    if (value == null)\r\n        return '';\r\n    // Use `String` so that it invokes the `toString` method of the value. Note that this\r\n    // appears to be faster than calling `value.toString` (see `render_stringify` benchmark).\r\n    return String(value);\r\n}\r\n/**\r\n * Used to stringify a value so that it can be displayed in an error message.\r\n *\r\n * Important! This function contains a megamorphic read and should only be\r\n * used for error messages.\r\n */\r\nfunction stringifyForError(value) {\r\n    if (typeof value === 'function')\r\n        return value.name || value.toString();\r\n    if (typeof value === 'object' && value != null && typeof value.type === 'function') {\r\n        return value.type.name || value.type.toString();\r\n    }\r\n    return renderStringify(value);\r\n}\r\n/**\r\n * Used to stringify a `Type` and including the file path and line number in which it is defined, if\r\n * possible, for better debugging experience.\r\n *\r\n * Important! This function contains a megamorphic read and should only be used for error messages.\r\n */\r\nfunction debugStringifyTypeForError(type) {\r\n    // TODO(pmvald): Do some refactoring so that we can use getComponentDef here without creating\r\n    // circular deps.\r\n    let componentDef = type[NG_COMP_DEF] || null;\r\n    if (componentDef !== null && componentDef.debugInfo) {\r\n        return stringifyTypeFromDebugInfo(componentDef.debugInfo);\r\n    }\r\n    return stringifyForError(type);\r\n}\r\n// TODO(pmvald): Do some refactoring so that we can use the type ClassDebugInfo for the param\r\n// debugInfo here without creating circular deps.\r\nfunction stringifyTypeFromDebugInfo(debugInfo) {\r\n    if (!debugInfo.filePath || !debugInfo.lineNumber) {\r\n        return debugInfo.className;\r\n    }\r\n    else {\r\n        return `${debugInfo.className} (at ${debugInfo.filePath}:${debugInfo.lineNumber})`;\r\n    }\r\n}\r\n\r\nconst NG_RUNTIME_ERROR_CODE = getClosureSafeProperty({ 'ngErrorCode': getClosureSafeProperty });\r\nconst NG_RUNTIME_ERROR_MESSAGE = getClosureSafeProperty({ 'ngErrorMessage': getClosureSafeProperty });\r\nconst NG_TOKEN_PATH = getClosureSafeProperty({ 'ngTokenPath': getClosureSafeProperty });\r\n/** Creates a circular dependency runtime error. */\r\nfunction cyclicDependencyError(token, path) {\r\n    const message = ngDevMode ? `Circular dependency detected for \\`${token}\\`.` : '';\r\n    return createRuntimeError(message, -200 /* RuntimeErrorCode.CYCLIC_DI_DEPENDENCY */, path);\r\n}\r\n/** Creates a circular dependency runtime error including a dependency path in the error message. */\r\nfunction cyclicDependencyErrorWithDetails(token, path) {\r\n    return augmentRuntimeError(cyclicDependencyError(token, path), null);\r\n}\r\nfunction throwMixedMultiProviderError() {\r\n    throw new Error(`Cannot mix multi providers and regular providers`);\r\n}\r\nfunction throwInvalidProviderError(ngModuleType, providers, provider) {\r\n    if (ngModuleType && providers) {\r\n        const providerDetail = providers.map((v) => (v == provider ? '?' + provider + '?' : '...'));\r\n        throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`);\r\n    }\r\n    else if (isEnvironmentProviders(provider)) {\r\n        if (provider.ɵfromNgModule) {\r\n            throw new RuntimeError(207 /* RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT */, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);\r\n        }\r\n        else {\r\n            throw new RuntimeError(207 /* RuntimeErrorCode.PROVIDER_IN_WRONG_CONTEXT */, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);\r\n        }\r\n    }\r\n    else {\r\n        throw new Error('Invalid provider');\r\n    }\r\n}\r\n/** Throws an error when a token is not found in DI. */\r\nfunction throwProviderNotFoundError(token, injectorName) {\r\n    const errorMessage = ngDevMode &&\r\n        `No provider for ${stringifyForError(token)} found${injectorName ? ` in ${injectorName}` : ''}`;\r\n    throw new RuntimeError(-201 /* RuntimeErrorCode.PROVIDER_NOT_FOUND */, errorMessage);\r\n}\r\n/**\r\n * Given an Error instance and the current token - update the monkey-patched\r\n * dependency path info to include that token.\r\n *\r\n * @param error Current instance of the Error class.\r\n * @param token Extra token that should be appended.\r\n */\r\nfunction prependTokenToDependencyPath(error, token) {\r\n    error[NG_TOKEN_PATH] ??= [];\r\n    // Append current token to the current token path. Since the error\r\n    // is bubbling up, add the token in front of other tokens.\r\n    const currentPath = error[NG_TOKEN_PATH];\r\n    // Do not append the same token multiple times.\r\n    let pathStr;\r\n    if (typeof token === 'object' && 'multi' in token && token?.multi === true) {\r\n        assertDefined(token.provide, 'Token with multi: true should have a provide property');\r\n        pathStr = stringifyForError(token.provide);\r\n    }\r\n    else {\r\n        pathStr = stringifyForError(token);\r\n    }\r\n    if (currentPath[0] !== pathStr) {\r\n        error[NG_TOKEN_PATH].unshift(pathStr);\r\n    }\r\n}\r\n/**\r\n * Modifies an Error instance with an updated error message\r\n * based on the accumulated dependency path.\r\n *\r\n * @param error Current instance of the Error class.\r\n * @param source Extra info about the injector which started\r\n *    the resolution process, which eventually failed.\r\n */\r\nfunction augmentRuntimeError(error, source) {\r\n    const tokenPath = error[NG_TOKEN_PATH];\r\n    const errorCode = error[NG_RUNTIME_ERROR_CODE];\r\n    const message = error[NG_RUNTIME_ERROR_MESSAGE] || error.message;\r\n    error.message = formatErrorMessage(message, errorCode, tokenPath, source);\r\n    return error;\r\n}\r\n/**\r\n * Creates an initial RuntimeError instance when a problem is detected.\r\n * Monkey-patches extra info in the RuntimeError instance, so that it can\r\n * be reused later, before throwing the final error.\r\n */\r\nfunction createRuntimeError(message, code, path) {\r\n    // Cast to `any`, so that extra info can be monkey-patched onto this instance.\r\n    const error = new RuntimeError(code, message);\r\n    // Monkey-patch a runtime error code and a path onto an Error instance.\r\n    error[NG_RUNTIME_ERROR_CODE] = code;\r\n    error[NG_RUNTIME_ERROR_MESSAGE] = message;\r\n    if (path) {\r\n        error[NG_TOKEN_PATH] = path;\r\n    }\r\n    return error;\r\n}\r\n/**\r\n * Reads monkey-patched error code from the given Error instance.\r\n */\r\nfunction getRuntimeErrorCode(error) {\r\n    return error[NG_RUNTIME_ERROR_CODE];\r\n}\r\nfunction formatErrorMessage(text, code, path = [], source = null) {\r\n    let pathDetails = '';\r\n    // If the path is empty or contains only one element (self) -\r\n    // do not append additional info the error message.\r\n    if (path && path.length > 1) {\r\n        pathDetails = ` Path: ${path.join(' -> ')}.`;\r\n    }\r\n    const sourceDetails = source ? ` Source: ${source}.` : '';\r\n    return formatRuntimeError(code, `${text}${sourceDetails}${pathDetails}`);\r\n}\r\n\r\n/**\r\n * Current implementation of inject.\r\n *\r\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\r\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\r\n * way for two reasons:\r\n *  1. `Injector` should not depend on ivy logic.\r\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\r\n */\r\nlet _injectImplementation;\r\nfunction getInjectImplementation() {\r\n    return _injectImplementation;\r\n}\r\n/**\r\n * Sets the current inject implementation.\r\n */\r\nfunction setInjectImplementation(impl) {\r\n    const previous = _injectImplementation;\r\n    _injectImplementation = impl;\r\n    return previous;\r\n}\r\n/**\r\n * Injects `root` tokens in limp mode.\r\n *\r\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\r\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\r\n * injectable definition.\r\n */\r\nfunction injectRootLimpMode(token, notFoundValue, flags) {\r\n    const injectableDef = getInjectableDef(token);\r\n    if (injectableDef && injectableDef.providedIn == 'root') {\r\n        return injectableDef.value === undefined\r\n            ? (injectableDef.value = injectableDef.factory())\r\n            : injectableDef.value;\r\n    }\r\n    if (flags & 8 /* InternalInjectFlags.Optional */)\r\n        return null;\r\n    if (notFoundValue !== undefined)\r\n        return notFoundValue;\r\n    throwProviderNotFoundError(token, 'Injector');\r\n}\r\n/**\r\n * Assert that `_injectImplementation` is not `fn`.\r\n *\r\n * This is useful, to prevent infinite recursion.\r\n *\r\n * @param fn Function which it should not equal to\r\n */\r\nfunction assertInjectImplementationNotEqual(fn) {\r\n    ngDevMode &&\r\n        assertNotEqual(_injectImplementation, fn, 'Calling ɵɵinject would cause infinite recursion');\r\n}\r\n\r\nconst _THROW_IF_NOT_FOUND = {};\r\nconst THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\r\n/*\r\n * Name of a property (that we patch onto DI decorator), which is used as an annotation of which\r\n * InjectFlag this decorator represents. This allows to avoid direct references to the DI decorators\r\n * in the code, thus making them tree-shakable.\r\n */\r\nconst DI_DECORATOR_FLAG = '__NG_DI_FLAG__';\r\n/**\r\n * A wrapper around an `Injector` that implements the `PrimitivesInjector` interface.\r\n *\r\n * This is used to allow the `inject` function to be used with the new primitives-based DI system.\r\n */\r\nclass RetrievingInjector {\r\n    injector;\r\n    constructor(injector) {\r\n        this.injector = injector;\r\n    }\r\n    retrieve(token, options) {\r\n        const flags = convertToBitFlags(options) || 0 /* InternalInjectFlags.Default */;\r\n        try {\r\n            return this.injector.get(token, \r\n            // When a dependency is requested with an optional flag, DI returns null as the default value.\r\n            (flags & 8 /* InternalInjectFlags.Optional */ ? null : THROW_IF_NOT_FOUND), flags);\r\n        }\r\n        catch (e) {\r\n            if (isNotFound(e)) {\r\n                return e;\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n}\r\nfunction injectInjectorOnly(token, flags = 0 /* InternalInjectFlags.Default */) {\r\n    const currentInjector = getCurrentInjector();\r\n    if (currentInjector === undefined) {\r\n        throw new RuntimeError(-203 /* RuntimeErrorCode.MISSING_INJECTION_CONTEXT */, ngDevMode &&\r\n            `The \\`${stringify(token)}\\` token injection failed. \\`inject()\\` function must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \\`runInInjectionContext\\`.`);\r\n    }\r\n    else if (currentInjector === null) {\r\n        return injectRootLimpMode(token, undefined, flags);\r\n    }\r\n    else {\r\n        const options = convertToInjectOptions(flags);\r\n        // TODO: improve the typings here.\r\n        // `token` can be a multi: true provider definition, which is considered as a Token but not represented in the typings\r\n        const value = currentInjector.retrieve(token, options);\r\n        ngDevMode && emitInjectEvent(token, value, flags);\r\n        if (isNotFound(value)) {\r\n            if (options.optional) {\r\n                return null;\r\n            }\r\n            throw value;\r\n        }\r\n        return value;\r\n    }\r\n}\r\nfunction ɵɵinject(token, flags = 0 /* InternalInjectFlags.Default */) {\r\n    return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);\r\n}\r\n/**\r\n * Throws an error indicating that a factory function could not be generated by the compiler for a\r\n * particular class.\r\n *\r\n * The name of the class is not mentioned here, but will be in the generated factory function name\r\n * and thus in the stack trace.\r\n *\r\n * @codeGenApi\r\n */\r\nfunction ɵɵinvalidFactoryDep(index) {\r\n    throw new RuntimeError(202 /* RuntimeErrorCode.INVALID_FACTORY_DEPENDENCY */, ngDevMode &&\r\n        `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\r\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\r\n\r\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);\r\n}\r\n/**\r\n * Injects a token from the currently active injector.\r\n * `inject` is only supported in an [injection context](guide/di/dependency-injection-context). It\r\n * can be used during:\r\n * - Construction (via the `constructor`) of a class being instantiated by the DI system, such\r\n * as an `@Injectable` or `@Component`.\r\n * - In the initializer for fields of such classes.\r\n * - In the factory function specified for `useFactory` of a `Provider` or an `@Injectable`.\r\n * - In the `factory` function specified for an `InjectionToken`.\r\n * - In a stackframe of a function call in a DI context\r\n *\r\n * @param token A token that represents a dependency that should be injected.\r\n * @param flags Optional flags that control how injection is executed.\r\n * The flags correspond to injection strategies that can be specified with\r\n * parameter decorators `@Host`, `@Self`, `@SkipSelf`, and `@Optional`.\r\n * @returns the injected value if operation is successful, `null` otherwise.\r\n * @throws if called outside of a supported context.\r\n *\r\n * @usageNotes\r\n * In practice the `inject()` calls are allowed in a constructor, a constructor parameter and a\r\n * field initializer:\r\n *\r\n * ```ts\r\n * @Injectable({providedIn: 'root'})\r\n * export class Car {\r\n *   radio: Radio|undefined;\r\n *   // OK: field initializer\r\n *   spareTyre = inject(Tyre);\r\n *\r\n *   constructor() {\r\n *     // OK: constructor body\r\n *     this.radio = inject(Radio);\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * It is also legal to call `inject` from a provider's factory:\r\n *\r\n * ```ts\r\n * providers: [\r\n *   {provide: Car, useFactory: () => {\r\n *     // OK: a class factory\r\n *     const engine = inject(Engine);\r\n *     return new Car(engine);\r\n *   }}\r\n * ]\r\n * ```\r\n *\r\n * Calls to the `inject()` function outside of the class creation context will result in error. Most\r\n * notably, calls to `inject()` are disallowed after a class instance was created, in methods\r\n * (including lifecycle hooks):\r\n *\r\n * ```ts\r\n * @Component({ ... })\r\n * export class CarComponent {\r\n *   ngOnInit() {\r\n *     // ERROR: too late, the component instance was already created\r\n *     const engine = inject(Engine);\r\n *     engine.start();\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nfunction inject(token, options) {\r\n    // The `as any` here _shouldn't_ be necessary, but without it JSCompiler\r\n    // throws a disambiguation  error due to the multiple signatures.\r\n    return ɵɵinject(token, convertToBitFlags(options));\r\n}\r\n// Converts object-based DI flags (`InjectOptions`) to bit flags (`InjectFlags`).\r\nfunction convertToBitFlags(flags) {\r\n    if (typeof flags === 'undefined' || typeof flags === 'number') {\r\n        return flags;\r\n    }\r\n    // While TypeScript doesn't accept it without a cast, bitwise OR with false-y values in\r\n    // JavaScript is a no-op. We can use that for a very codesize-efficient conversion from\r\n    // `InjectOptions` to `InjectFlags`.\r\n    return (0 /* InternalInjectFlags.Default */ | // comment to force a line break in the formatter\r\n        (flags.optional && 8 /* InternalInjectFlags.Optional */) |\r\n        (flags.host && 1 /* InternalInjectFlags.Host */) |\r\n        (flags.self && 2 /* InternalInjectFlags.Self */) |\r\n        (flags.skipSelf && 4 /* InternalInjectFlags.SkipSelf */));\r\n}\r\n// Converts bitflags to inject options\r\nfunction convertToInjectOptions(flags) {\r\n    return {\r\n        optional: !!(flags & 8 /* InternalInjectFlags.Optional */),\r\n        host: !!(flags & 1 /* InternalInjectFlags.Host */),\r\n        self: !!(flags & 2 /* InternalInjectFlags.Self */),\r\n        skipSelf: !!(flags & 4 /* InternalInjectFlags.SkipSelf */),\r\n    };\r\n}\r\nfunction injectArgs(types) {\r\n    const args = [];\r\n    for (let i = 0; i < types.length; i++) {\r\n        const arg = resolveForwardRef(types[i]);\r\n        if (Array.isArray(arg)) {\r\n            if (arg.length === 0) {\r\n                throw new RuntimeError(900 /* RuntimeErrorCode.INVALID_DIFFER_INPUT */, ngDevMode && 'Arguments array must have arguments.');\r\n            }\r\n            let type = undefined;\r\n            let flags = 0 /* InternalInjectFlags.Default */;\r\n            for (let j = 0; j < arg.length; j++) {\r\n                const meta = arg[j];\r\n                const flag = getInjectFlag(meta);\r\n                if (typeof flag === 'number') {\r\n                    // Special case when we handle @Inject decorator.\r\n                    if (flag === -1 /* DecoratorFlags.Inject */) {\r\n                        type = meta.token;\r\n                    }\r\n                    else {\r\n                        flags |= flag;\r\n                    }\r\n                }\r\n                else {\r\n                    type = meta;\r\n                }\r\n            }\r\n            args.push(ɵɵinject(type, flags));\r\n        }\r\n        else {\r\n            args.push(ɵɵinject(arg));\r\n        }\r\n    }\r\n    return args;\r\n}\r\n/**\r\n * Attaches a given InjectFlag to a given decorator using monkey-patching.\r\n * Since DI decorators can be used in providers `deps` array (when provider is configured using\r\n * `useFactory`) without initialization (e.g. `Host`) and as an instance (e.g. `new Host()`), we\r\n * attach the flag to make it available both as a static property and as a field on decorator\r\n * instance.\r\n *\r\n * @param decorator Provided DI decorator.\r\n * @param flag InjectFlag that should be applied.\r\n */\r\nfunction attachInjectFlag(decorator, flag) {\r\n    decorator[DI_DECORATOR_FLAG] = flag;\r\n    decorator.prototype[DI_DECORATOR_FLAG] = flag;\r\n    return decorator;\r\n}\r\n/**\r\n * Reads monkey-patched property that contains InjectFlag attached to a decorator.\r\n *\r\n * @param token Token that may contain monkey-patched DI flags property.\r\n */\r\nfunction getInjectFlag(token) {\r\n    return token[DI_DECORATOR_FLAG];\r\n}\r\n\r\nfunction getFactoryDef(type, throwNotFound) {\r\n    const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\r\n    if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\r\n        throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);\r\n    }\r\n    return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\r\n}\r\n\r\n/**\r\n * Determines if the contents of two arrays is identical\r\n *\r\n * @param a first array\r\n * @param b second array\r\n * @param identityAccessor Optional function for extracting stable object identity from a value in\r\n *     the array.\r\n */\r\nfunction arrayEquals(a, b, identityAccessor) {\r\n    if (a.length !== b.length)\r\n        return false;\r\n    for (let i = 0; i < a.length; i++) {\r\n        let valueA = a[i];\r\n        let valueB = b[i];\r\n        if (identityAccessor) {\r\n            valueA = identityAccessor(valueA);\r\n            valueB = identityAccessor(valueB);\r\n        }\r\n        if (valueB !== valueA) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Flattens an array.\r\n */\r\nfunction flatten(list) {\r\n    return list.flat(Number.POSITIVE_INFINITY);\r\n}\r\nfunction deepForEach(input, fn) {\r\n    input.forEach((value) => (Array.isArray(value) ? deepForEach(value, fn) : fn(value)));\r\n}\r\nfunction addToArray(arr, index, value) {\r\n    // perf: array.push is faster than array.splice!\r\n    if (index >= arr.length) {\r\n        arr.push(value);\r\n    }\r\n    else {\r\n        arr.splice(index, 0, value);\r\n    }\r\n}\r\nfunction removeFromArray(arr, index) {\r\n    // perf: array.pop is faster than array.splice!\r\n    if (index >= arr.length - 1) {\r\n        return arr.pop();\r\n    }\r\n    else {\r\n        return arr.splice(index, 1)[0];\r\n    }\r\n}\r\nfunction newArray(size, value) {\r\n    const list = [];\r\n    for (let i = 0; i < size; i++) {\r\n        list.push(value);\r\n    }\r\n    return list;\r\n}\r\n/**\r\n * Remove item from array (Same as `Array.splice()` but faster.)\r\n *\r\n * `Array.splice()` is not as fast because it has to allocate an array for the elements which were\r\n * removed. This causes memory pressure and slows down code when most of the time we don't\r\n * care about the deleted items array.\r\n *\r\n * https://jsperf.com/fast-array-splice (About 20x faster)\r\n *\r\n * @param array Array to splice\r\n * @param index Index of element in array to remove.\r\n * @param count Number of items to remove.\r\n */\r\nfunction arraySplice(array, index, count) {\r\n    const length = array.length - count;\r\n    while (index < length) {\r\n        array[index] = array[index + count];\r\n        index++;\r\n    }\r\n    while (count--) {\r\n        array.pop(); // shrink the array\r\n    }\r\n}\r\n/**\r\n * Same as `Array.splice2(index, 0, value1, value2)` but faster.\r\n *\r\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\r\n * removed. This causes memory pressure and slows down code when most of the time we don't\r\n * care about the deleted items array.\r\n *\r\n * @param array Array to splice.\r\n * @param index Index in array where the `value` should be added.\r\n * @param value1 Value to add to array.\r\n * @param value2 Value to add to array.\r\n */\r\nfunction arrayInsert2(array, index, value1, value2) {\r\n    ngDevMode && assertLessThanOrEqual(index, array.length, \"Can't insert past array end.\");\r\n    let end = array.length;\r\n    if (end == index) {\r\n        // inserting at the end.\r\n        array.push(value1, value2);\r\n    }\r\n    else if (end === 1) {\r\n        // corner case when we have less items in array than we have items to insert.\r\n        array.push(value2, array[0]);\r\n        array[0] = value1;\r\n    }\r\n    else {\r\n        end--;\r\n        array.push(array[end - 1], array[end]);\r\n        while (end > index) {\r\n            const previousEnd = end - 2;\r\n            array[end] = array[previousEnd];\r\n            end--;\r\n        }\r\n        array[index] = value1;\r\n        array[index + 1] = value2;\r\n    }\r\n}\r\n/**\r\n * Set a `value` for a `key`.\r\n *\r\n * @param keyValueArray to modify.\r\n * @param key The key to locate or create.\r\n * @param value The value to set for a `key`.\r\n * @returns index (always even) of where the value vas set.\r\n */\r\nfunction keyValueArraySet(keyValueArray, key, value) {\r\n    let index = keyValueArrayIndexOf(keyValueArray, key);\r\n    if (index >= 0) {\r\n        // if we found it set it.\r\n        keyValueArray[index | 1] = value;\r\n    }\r\n    else {\r\n        index = ~index;\r\n        arrayInsert2(keyValueArray, index, key, value);\r\n    }\r\n    return index;\r\n}\r\n/**\r\n * Retrieve a `value` for a `key` (on `undefined` if not found.)\r\n *\r\n * @param keyValueArray to search.\r\n * @param key The key to locate.\r\n * @return The `value` stored at the `key` location or `undefined if not found.\r\n */\r\nfunction keyValueArrayGet(keyValueArray, key) {\r\n    const index = keyValueArrayIndexOf(keyValueArray, key);\r\n    if (index >= 0) {\r\n        // if we found it retrieve it.\r\n        return keyValueArray[index | 1];\r\n    }\r\n    return undefined;\r\n}\r\n/**\r\n * Retrieve a `key` index value in the array or `-1` if not found.\r\n *\r\n * @param keyValueArray to search.\r\n * @param key The key to locate.\r\n * @returns index of where the key is (or should have been.)\r\n *   - positive (even) index if key found.\r\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\r\n *     been inserted.)\r\n */\r\nfunction keyValueArrayIndexOf(keyValueArray, key) {\r\n    return _arrayIndexOfSorted(keyValueArray, key, 1);\r\n}\r\n/**\r\n * INTERNAL: Get an index of an `value` in a sorted `array` by grouping search by `shift`.\r\n *\r\n * NOTE:\r\n * - This uses binary search algorithm for fast removals.\r\n *\r\n * @param array A sorted array to binary search.\r\n * @param value The value to look for.\r\n * @param shift grouping shift.\r\n *   - `0` means look at every location\r\n *   - `1` means only look at every other (even) location (the odd locations are to be ignored as\r\n *         they are values.)\r\n * @returns index of the value.\r\n *   - positive index if value found.\r\n *   - negative index if value not found. (`~index` to get the value where it should have been\r\n * inserted)\r\n */\r\nfunction _arrayIndexOfSorted(array, value, shift) {\r\n    ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');\r\n    let start = 0;\r\n    let end = array.length >> shift;\r\n    while (end !== start) {\r\n        const middle = start + ((end - start) >> 1); // find the middle.\r\n        const current = array[middle << shift];\r\n        if (value === current) {\r\n            return middle << shift;\r\n        }\r\n        else if (current > value) {\r\n            end = middle;\r\n        }\r\n        else {\r\n            start = middle + 1; // We already searched middle so make it non-inclusive by adding 1\r\n        }\r\n    }\r\n    return ~(end << shift);\r\n}\r\n\r\n/**\r\n * This file contains reuseable \"empty\" symbols that can be used as default return values\r\n * in different parts of the rendering code. Because the same symbols are returned, this\r\n * allows for identity checks against these values to be consistently used by the framework\r\n * code.\r\n */\r\nconst EMPTY_OBJ = {};\r\nconst EMPTY_ARRAY = [];\r\n// freezing the values prevents any code from accidentally inserting new values in\r\nif ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {\r\n    // These property accesses can be ignored because ngDevMode will be set to false\r\n    // when optimizing code and the whole if statement will be dropped.\r\n    // tslint:disable-next-line:no-toplevel-property-access\r\n    Object.freeze(EMPTY_OBJ);\r\n    // tslint:disable-next-line:no-toplevel-property-access\r\n    Object.freeze(EMPTY_ARRAY);\r\n}\r\n\r\n/**\r\n * A multi-provider token for initialization functions that will run upon construction of an\r\n * environment injector.\r\n *\r\n * @deprecated from v19.0.0, use provideEnvironmentInitializer instead\r\n *\r\n * @see {@link provideEnvironmentInitializer}\r\n *\r\n * Note: As opposed to the `APP_INITIALIZER` token, the `ENVIRONMENT_INITIALIZER` functions are not awaited,\r\n * hence they should not be `async`.\r\n *\r\n * @publicApi\r\n */\r\nconst ENVIRONMENT_INITIALIZER = new InjectionToken(ngDevMode ? 'ENVIRONMENT_INITIALIZER' : '');\r\n\r\n/**\r\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\r\n *\r\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\r\n * project.\r\n *\r\n * @publicApi\r\n */\r\nconst INJECTOR$1 = new InjectionToken(ngDevMode ? 'INJECTOR' : '', \r\n// Disable tslint because this is const enum which gets inlined not top level prop access.\r\n// tslint:disable-next-line: no-toplevel-property-access\r\n-1 /* InjectorMarkers.Injector */);\r\n\r\nconst INJECTOR_DEF_TYPES = new InjectionToken(ngDevMode ? 'INJECTOR_DEF_TYPES' : '');\r\n\r\nclass NullInjector {\r\n    get(token, notFoundValue = THROW_IF_NOT_FOUND) {\r\n        if (notFoundValue === THROW_IF_NOT_FOUND) {\r\n            const message = ngDevMode ? `No provider found for \\`${stringify(token)}\\`.` : '';\r\n            const error = createRuntimeError(message, -201 /* RuntimeErrorCode.PROVIDER_NOT_FOUND */);\r\n            // Note: This is the name used by the primitives to identify a not found error.\r\n            error.name = 'ɵNotFound';\r\n            throw error;\r\n        }\r\n        return notFoundValue;\r\n    }\r\n}\r\n\r\nfunction getNgModuleDef(type) {\r\n    return type[NG_MOD_DEF] || null;\r\n}\r\nfunction getNgModuleDefOrThrow(type) {\r\n    const ngModuleDef = getNgModuleDef(type);\r\n    if (!ngModuleDef) {\r\n        throw new RuntimeError(915 /* RuntimeErrorCode.MISSING_NG_MODULE_DEFINITION */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n            `Type ${stringify(type)} does not have 'ɵmod' property.`);\r\n    }\r\n    return ngModuleDef;\r\n}\r\n/**\r\n * The following getter methods retrieve the definition from the type. Currently the retrieval\r\n * honors inheritance, but in the future we may change the rule to require that definitions are\r\n * explicit. This would require some sort of migration strategy.\r\n */\r\nfunction getComponentDef(type) {\r\n    return type[NG_COMP_DEF] || null;\r\n}\r\nfunction getDirectiveDefOrThrow(type) {\r\n    const def = getDirectiveDef(type);\r\n    if (!def) {\r\n        throw new RuntimeError(916 /* RuntimeErrorCode.MISSING_DIRECTIVE_DEFINITION */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n            `Type ${stringify(type)} does not have 'ɵdir' property.`);\r\n    }\r\n    return def;\r\n}\r\nfunction getDirectiveDef(type) {\r\n    return type[NG_DIR_DEF] || null;\r\n}\r\nfunction getPipeDef(type) {\r\n    return type[NG_PIPE_DEF] || null;\r\n}\r\n/**\r\n * Checks whether a given Component, Directive or Pipe is marked as standalone.\r\n * This will return false if passed anything other than a Component, Directive, or Pipe class\r\n * See [this guide](guide/components/importing) for additional information:\r\n *\r\n * @param type A reference to a Component, Directive or Pipe.\r\n * @publicApi\r\n */\r\nfunction isStandalone(type) {\r\n    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);\r\n    return def !== null && def.standalone;\r\n}\r\n\r\n/**\r\n * Wrap an array of `Provider`s into `EnvironmentProviders`, preventing them from being accidentally\r\n * referenced in `@Component` in a component injector.\r\n *\r\n * @publicApi\r\n */\r\nfunction makeEnvironmentProviders(providers) {\r\n    return {\r\n        ɵproviders: providers,\r\n    };\r\n}\r\n/**\r\n * @description\r\n * This function is used to provide initialization functions that will be executed upon construction\r\n * of an environment injector.\r\n *\r\n * Note that the provided initializer is run in the injection context.\r\n *\r\n * Previously, this was achieved using the `ENVIRONMENT_INITIALIZER` token which is now deprecated.\r\n *\r\n * @see {@link ENVIRONMENT_INITIALIZER}\r\n *\r\n * @usageNotes\r\n * The following example illustrates how to configure an initialization function using\r\n * `provideEnvironmentInitializer()`\r\n * ```ts\r\n * createEnvironmentInjector(\r\n *   [\r\n *     provideEnvironmentInitializer(() => {\r\n *       console.log('environment initialized');\r\n *     }),\r\n *   ],\r\n *   parentInjector\r\n * );\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nfunction provideEnvironmentInitializer(initializerFn) {\r\n    return makeEnvironmentProviders([\r\n        {\r\n            provide: ENVIRONMENT_INITIALIZER,\r\n            multi: true,\r\n            useValue: initializerFn,\r\n        },\r\n    ]);\r\n}\r\n/**\r\n * Collects providers from all NgModules and standalone components, including transitively imported\r\n * ones.\r\n *\r\n * Providers extracted via `importProvidersFrom` are only usable in an application injector or\r\n * another environment injector (such as a route injector). They should not be used in component\r\n * providers.\r\n *\r\n * More information about standalone components can be found in [this\r\n * guide](guide/components/importing).\r\n *\r\n * @usageNotes\r\n * The results of the `importProvidersFrom` call can be used in the `bootstrapApplication` call:\r\n *\r\n * ```ts\r\n * await bootstrapApplication(RootComponent, {\r\n *   providers: [\r\n *     importProvidersFrom(NgModuleOne, NgModuleTwo)\r\n *   ]\r\n * });\r\n * ```\r\n *\r\n * You can also use the `importProvidersFrom` results in the `providers` field of a route, when a\r\n * standalone component is used:\r\n *\r\n * ```ts\r\n * export const ROUTES: Route[] = [\r\n *   {\r\n *     path: 'foo',\r\n *     providers: [\r\n *       importProvidersFrom(NgModuleOne, NgModuleTwo)\r\n *     ],\r\n *     component: YourStandaloneComponent\r\n *   }\r\n * ];\r\n * ```\r\n *\r\n * @returns Collected providers from the specified list of types.\r\n * @publicApi\r\n */\r\nfunction importProvidersFrom(...sources) {\r\n    return {\r\n        ɵproviders: internalImportProvidersFrom(true, sources),\r\n        ɵfromNgModule: true,\r\n    };\r\n}\r\nfunction internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {\r\n    const providersOut = [];\r\n    const dedup = new Set(); // already seen types\r\n    let injectorTypesWithProviders;\r\n    const collectProviders = (provider) => {\r\n        providersOut.push(provider);\r\n    };\r\n    deepForEach(sources, (source) => {\r\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && checkForStandaloneCmp) {\r\n            const cmpDef = getComponentDef(source);\r\n            if (cmpDef?.standalone) {\r\n                throw new RuntimeError(800 /* RuntimeErrorCode.IMPORT_PROVIDERS_FROM_STANDALONE */, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component \"${stringifyForError(source)}\"`);\r\n            }\r\n        }\r\n        // Narrow `source` to access the internal type analogue for `ModuleWithProviders`.\r\n        const internalSource = source;\r\n        if (walkProviderTree(internalSource, collectProviders, [], dedup)) {\r\n            injectorTypesWithProviders ||= [];\r\n            injectorTypesWithProviders.push(internalSource);\r\n        }\r\n    });\r\n    // Collect all providers from `ModuleWithProviders` types.\r\n    if (injectorTypesWithProviders !== undefined) {\r\n        processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);\r\n    }\r\n    return providersOut;\r\n}\r\n/**\r\n * Collects all providers from the list of `ModuleWithProviders` and appends them to the provided\r\n * array.\r\n */\r\nfunction processInjectorTypesWithProviders(typesWithProviders, visitor) {\r\n    for (let i = 0; i < typesWithProviders.length; i++) {\r\n        const { ngModule, providers } = typesWithProviders[i];\r\n        deepForEachProvider(providers, (provider) => {\r\n            ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);\r\n            visitor(provider, ngModule);\r\n        });\r\n    }\r\n}\r\n/**\r\n * The logic visits an `InjectorType`, an `InjectorTypeWithProviders`, or a standalone\r\n * `ComponentType`, and all of its transitive providers and collects providers.\r\n *\r\n * If an `InjectorTypeWithProviders` that declares providers besides the type is specified,\r\n * the function will return \"true\" to indicate that the providers of the type definition need\r\n * to be processed. This allows us to process providers of injector types after all imports of\r\n * an injector definition are processed. (following View Engine semantics: see FW-1349)\r\n */\r\nfunction walkProviderTree(container, visitor, parents, dedup) {\r\n    container = resolveForwardRef(container);\r\n    if (!container)\r\n        return false;\r\n    // The actual type which had the definition. Usually `container`, but may be an unwrapped type\r\n    // from `InjectorTypeWithProviders`.\r\n    let defType = null;\r\n    let injDef = getInjectorDef(container);\r\n    const cmpDef = !injDef && getComponentDef(container);\r\n    if (!injDef && !cmpDef) {\r\n        // `container` is not an injector type or a component type. It might be:\r\n        //  * An `InjectorTypeWithProviders` that wraps an injector type.\r\n        //  * A standalone directive or pipe that got pulled in from a standalone component's\r\n        //    dependencies.\r\n        // Try to unwrap it as an `InjectorTypeWithProviders` first.\r\n        const ngModule = container\r\n            .ngModule;\r\n        injDef = getInjectorDef(ngModule);\r\n        if (injDef) {\r\n            defType = ngModule;\r\n        }\r\n        else {\r\n            // Not a component or injector type, so ignore it.\r\n            return false;\r\n        }\r\n    }\r\n    else if (cmpDef && !cmpDef.standalone) {\r\n        return false;\r\n    }\r\n    else {\r\n        defType = container;\r\n    }\r\n    // Check for circular dependencies.\r\n    if (ngDevMode && parents.indexOf(defType) !== -1) {\r\n        const defName = stringify(defType);\r\n        const path = parents.map(stringify).concat(defName);\r\n        throw cyclicDependencyErrorWithDetails(defName, path);\r\n    }\r\n    // Check for multiple imports of the same module\r\n    const isDuplicate = dedup.has(defType);\r\n    if (cmpDef) {\r\n        if (isDuplicate) {\r\n            // This component definition has already been processed.\r\n            return false;\r\n        }\r\n        dedup.add(defType);\r\n        if (cmpDef.dependencies) {\r\n            const deps = typeof cmpDef.dependencies === 'function' ? cmpDef.dependencies() : cmpDef.dependencies;\r\n            for (const dep of deps) {\r\n                walkProviderTree(dep, visitor, parents, dedup);\r\n            }\r\n        }\r\n    }\r\n    else if (injDef) {\r\n        // First, include providers from any imports.\r\n        if (injDef.imports != null && !isDuplicate) {\r\n            // Before processing defType's imports, add it to the set of parents. This way, if it ends\r\n            // up deeply importing itself, this can be detected.\r\n            ngDevMode && parents.push(defType);\r\n            // Add it to the set of dedups. This way we can detect multiple imports of the same module\r\n            dedup.add(defType);\r\n            let importTypesWithProviders;\r\n            try {\r\n                deepForEach(injDef.imports, (imported) => {\r\n                    if (walkProviderTree(imported, visitor, parents, dedup)) {\r\n                        importTypesWithProviders ||= [];\r\n                        // If the processed import is an injector type with providers, we store it in the\r\n                        // list of import types with providers, so that we can process those afterwards.\r\n                        importTypesWithProviders.push(imported);\r\n                    }\r\n                });\r\n            }\r\n            finally {\r\n                // Remove it from the parents set when finished.\r\n                ngDevMode && parents.pop();\r\n            }\r\n            // Imports which are declared with providers (TypeWithProviders) need to be processed\r\n            // after all imported modules are processed. This is similar to how View Engine\r\n            // processes/merges module imports in the metadata resolver. See: FW-1349.\r\n            if (importTypesWithProviders !== undefined) {\r\n                processInjectorTypesWithProviders(importTypesWithProviders, visitor);\r\n            }\r\n        }\r\n        if (!isDuplicate) {\r\n            // Track the InjectorType and add a provider for it.\r\n            // It's important that this is done after the def's imports.\r\n            const factory = getFactoryDef(defType) || (() => new defType());\r\n            // Append extra providers to make more info available for consumers (to retrieve an injector\r\n            // type), as well as internally (to calculate an injection scope correctly and eagerly\r\n            // instantiate a `defType` when an injector is created).\r\n            // Provider to create `defType` using its factory.\r\n            visitor({ provide: defType, useFactory: factory, deps: EMPTY_ARRAY }, defType);\r\n            // Make this `defType` available to an internal logic that calculates injector scope.\r\n            visitor({ provide: INJECTOR_DEF_TYPES, useValue: defType, multi: true }, defType);\r\n            // Provider to eagerly instantiate `defType` via `INJECTOR_INITIALIZER`.\r\n            visitor({ provide: ENVIRONMENT_INITIALIZER, useValue: () => ɵɵinject(defType), multi: true }, defType);\r\n        }\r\n        // Next, include providers listed on the definition itself.\r\n        const defProviders = injDef.providers;\r\n        if (defProviders != null && !isDuplicate) {\r\n            const injectorType = container;\r\n            deepForEachProvider(defProviders, (provider) => {\r\n                ngDevMode && validateProvider(provider, defProviders, injectorType);\r\n                visitor(provider, injectorType);\r\n            });\r\n        }\r\n    }\r\n    else {\r\n        // Should not happen, but just in case.\r\n        return false;\r\n    }\r\n    return (defType !== container && container.providers !== undefined);\r\n}\r\nfunction validateProvider(provider, providers, containerType) {\r\n    if (isTypeProvider(provider) ||\r\n        isValueProvider(provider) ||\r\n        isFactoryProvider(provider) ||\r\n        isExistingProvider(provider)) {\r\n        return;\r\n    }\r\n    // Here we expect the provider to be a `useClass` provider (by elimination).\r\n    const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\r\n    if (!classRef) {\r\n        throwInvalidProviderError(containerType, providers, provider);\r\n    }\r\n}\r\nfunction deepForEachProvider(providers, fn) {\r\n    for (let provider of providers) {\r\n        if (isEnvironmentProviders(provider)) {\r\n            provider = provider.ɵproviders;\r\n        }\r\n        if (Array.isArray(provider)) {\r\n            deepForEachProvider(provider, fn);\r\n        }\r\n        else {\r\n            fn(provider);\r\n        }\r\n    }\r\n}\r\nconst USE_VALUE = getClosureSafeProperty({\r\n    provide: String,\r\n    useValue: getClosureSafeProperty,\r\n});\r\nfunction isValueProvider(value) {\r\n    return value !== null && typeof value == 'object' && USE_VALUE in value;\r\n}\r\nfunction isExistingProvider(value) {\r\n    return !!(value && value.useExisting);\r\n}\r\nfunction isFactoryProvider(value) {\r\n    return !!(value && value.useFactory);\r\n}\r\nfunction isTypeProvider(value) {\r\n    return typeof value === 'function';\r\n}\r\nfunction isClassProvider(value) {\r\n    return !!value.useClass;\r\n}\r\n\r\n/**\r\n * An internal token whose presence in an injector indicates that the injector should treat itself\r\n * as a root scoped injector when processing requests for unknown tokens which may indicate\r\n * they are provided in the root scope.\r\n */\r\nconst INJECTOR_SCOPE = new InjectionToken(ngDevMode ? 'Set Injector scope.' : '');\r\n\r\n/**\r\n * Marker which indicates that a value has not yet been created from the factory function.\r\n */\r\nconst NOT_YET = {};\r\n/**\r\n * Marker which indicates that the factory function for a token is in the process of being called.\r\n *\r\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\r\n * injection of a dependency has recursively attempted to inject the original token, and there is\r\n * a circular dependency among the providers.\r\n */\r\nconst CIRCULAR = {};\r\n/**\r\n * A lazily initialized NullInjector.\r\n */\r\nlet NULL_INJECTOR = undefined;\r\nfunction getNullInjector() {\r\n    if (NULL_INJECTOR === undefined) {\r\n        NULL_INJECTOR = new NullInjector();\r\n    }\r\n    return NULL_INJECTOR;\r\n}\r\n/**\r\n * An `Injector` that's part of the environment injector hierarchy, which exists outside of the\r\n * component tree.\r\n *\r\n * @publicApi\r\n */\r\nclass EnvironmentInjector {\r\n}\r\nclass R3Injector extends EnvironmentInjector {\r\n    parent;\r\n    source;\r\n    scopes;\r\n    /**\r\n     * Map of tokens to records which contain the instances of those tokens.\r\n     * - `null` value implies that we don't have the record. Used by tree-shakable injectors\r\n     * to prevent further searches.\r\n     */\r\n    records = new Map();\r\n    /**\r\n     * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\r\n     */\r\n    _ngOnDestroyHooks = new Set();\r\n    _onDestroyHooks = [];\r\n    /**\r\n     * Flag indicating that this injector was previously destroyed.\r\n     */\r\n    get destroyed() {\r\n        return this._destroyed;\r\n    }\r\n    _destroyed = false;\r\n    injectorDefTypes;\r\n    constructor(providers, parent, source, scopes) {\r\n        super();\r\n        this.parent = parent;\r\n        this.source = source;\r\n        this.scopes = scopes;\r\n        // Start off by creating Records for every provider.\r\n        forEachSingleProvider(providers, (provider) => this.processProvider(provider));\r\n        // Make sure the INJECTOR token provides this injector.\r\n        this.records.set(INJECTOR$1, makeRecord(undefined, this));\r\n        // And `EnvironmentInjector` if the current injector is supposed to be env-scoped.\r\n        if (scopes.has('environment')) {\r\n            this.records.set(EnvironmentInjector, makeRecord(undefined, this));\r\n        }\r\n        // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\r\n        // any injectable scoped to APP_ROOT_SCOPE.\r\n        const record = this.records.get(INJECTOR_SCOPE);\r\n        if (record != null && typeof record.value === 'string') {\r\n            this.scopes.add(record.value);\r\n        }\r\n        this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES, EMPTY_ARRAY, { self: true }));\r\n    }\r\n    retrieve(token, options) {\r\n        const flags = convertToBitFlags(options) || 0 /* InternalInjectFlags.Default */;\r\n        try {\r\n            return this.get(token, \r\n            // When a dependency is requested with an optional flag, DI returns null as the default value.\r\n            THROW_IF_NOT_FOUND, flags);\r\n        }\r\n        catch (e) {\r\n            if (isNotFound$1(e)) {\r\n                return e;\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n    /**\r\n     * Destroy the injector and release references to every instance or provider associated with it.\r\n     *\r\n     * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\r\n     * hook was found.\r\n     */\r\n    destroy() {\r\n        assertNotDestroyed(this);\r\n        // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\r\n        this._destroyed = true;\r\n        const prevConsumer = setActiveConsumer(null);\r\n        try {\r\n            // Call all the lifecycle hooks.\r\n            for (const service of this._ngOnDestroyHooks) {\r\n                service.ngOnDestroy();\r\n            }\r\n            const onDestroyHooks = this._onDestroyHooks;\r\n            // Reset the _onDestroyHooks array before iterating over it to prevent hooks that unregister\r\n            // themselves from mutating the array during iteration.\r\n            this._onDestroyHooks = [];\r\n            for (const hook of onDestroyHooks) {\r\n                hook();\r\n            }\r\n        }\r\n        finally {\r\n            // Release all references.\r\n            this.records.clear();\r\n            this._ngOnDestroyHooks.clear();\r\n            this.injectorDefTypes.clear();\r\n            setActiveConsumer(prevConsumer);\r\n        }\r\n    }\r\n    onDestroy(callback) {\r\n        assertNotDestroyed(this);\r\n        this._onDestroyHooks.push(callback);\r\n        return () => this.removeOnDestroy(callback);\r\n    }\r\n    runInContext(fn) {\r\n        assertNotDestroyed(this);\r\n        const previousInjector = setCurrentInjector(this);\r\n        const previousInjectImplementation = setInjectImplementation(undefined);\r\n        let prevInjectContext;\r\n        if (ngDevMode) {\r\n            prevInjectContext = setInjectorProfilerContext({ injector: this, token: null });\r\n        }\r\n        try {\r\n            return fn();\r\n        }\r\n        finally {\r\n            setCurrentInjector(previousInjector);\r\n            setInjectImplementation(previousInjectImplementation);\r\n            ngDevMode && setInjectorProfilerContext(prevInjectContext);\r\n        }\r\n    }\r\n    get(token, notFoundValue = THROW_IF_NOT_FOUND, options) {\r\n        assertNotDestroyed(this);\r\n        if (token.hasOwnProperty(NG_ENV_ID)) {\r\n            return token[NG_ENV_ID](this);\r\n        }\r\n        const flags = convertToBitFlags(options);\r\n        // Set the injection context.\r\n        let prevInjectContext;\r\n        if (ngDevMode) {\r\n            prevInjectContext = setInjectorProfilerContext({ injector: this, token: token });\r\n        }\r\n        const previousInjector = setCurrentInjector(this);\r\n        const previousInjectImplementation = setInjectImplementation(undefined);\r\n        try {\r\n            // Check for the SkipSelf flag.\r\n            if (!(flags & 4 /* InternalInjectFlags.SkipSelf */)) {\r\n                // SkipSelf isn't set, check if the record belongs to this injector.\r\n                let record = this.records.get(token);\r\n                if (record === undefined) {\r\n                    // No record, but maybe the token is scoped to this injector. Look for an injectable\r\n                    // def with a scope matching this injector.\r\n                    const def = couldBeInjectableType(token) && getInjectableDef(token);\r\n                    if (def && this.injectableDefInScope(def)) {\r\n                        // Found an injectable def and it's scoped to this injector. Pretend as if it was here\r\n                        // all along.\r\n                        if (ngDevMode) {\r\n                            runInInjectorProfilerContext(this, token, () => {\r\n                                emitProviderConfiguredEvent(token);\r\n                            });\r\n                        }\r\n                        record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);\r\n                    }\r\n                    else {\r\n                        record = null;\r\n                    }\r\n                    this.records.set(token, record);\r\n                }\r\n                // If a record was found, get the instance for it and return it.\r\n                if (record != null /* NOT null || undefined */) {\r\n                    return this.hydrate(token, record, flags);\r\n                }\r\n            }\r\n            // Select the next injector based on the Self flag - if self is set, the next injector is\r\n            // the NullInjector, otherwise it's the parent.\r\n            const nextInjector = !(flags & 2 /* InternalInjectFlags.Self */) ? this.parent : getNullInjector();\r\n            // Set the notFoundValue based on the Optional flag - if optional is set and notFoundValue\r\n            // is undefined, the value is null, otherwise it's the notFoundValue.\r\n            notFoundValue =\r\n                flags & 8 /* InternalInjectFlags.Optional */ && notFoundValue === THROW_IF_NOT_FOUND\r\n                    ? null\r\n                    : notFoundValue;\r\n            return nextInjector.get(token, notFoundValue);\r\n        }\r\n        catch (error) {\r\n            // If there was a cyclic dependency error or a token was not found,\r\n            // an error is thrown at the level where the problem was detected.\r\n            // The error propagates up the call stack and the code below appends\r\n            // the current token into the path. As a result, the full path is assembled\r\n            // at the very top of the call stack, so the final error message can be\r\n            // formatted to include that path.\r\n            const errorCode = getRuntimeErrorCode(error);\r\n            if (errorCode === -200 /* RuntimeErrorCode.CYCLIC_DI_DEPENDENCY */ ||\r\n                errorCode === -201 /* RuntimeErrorCode.PROVIDER_NOT_FOUND */) {\r\n                if (!ngDevMode) {\r\n                    throw new RuntimeError(errorCode, null);\r\n                }\r\n                prependTokenToDependencyPath(error, token);\r\n                if (previousInjector) {\r\n                    // We still have a parent injector, keep throwing\r\n                    throw error;\r\n                }\r\n                else {\r\n                    // Format & throw the final error message when we don't have any previous injector\r\n                    throw augmentRuntimeError(error, this.source);\r\n                }\r\n            }\r\n            else {\r\n                throw error;\r\n            }\r\n        }\r\n        finally {\r\n            // Lastly, restore the previous injection context.\r\n            setInjectImplementation(previousInjectImplementation);\r\n            setCurrentInjector(previousInjector);\r\n            ngDevMode && setInjectorProfilerContext(prevInjectContext);\r\n        }\r\n    }\r\n    /** @internal */\r\n    resolveInjectorInitializers() {\r\n        const prevConsumer = setActiveConsumer(null);\r\n        const previousInjector = setCurrentInjector(this);\r\n        const previousInjectImplementation = setInjectImplementation(undefined);\r\n        let prevInjectContext;\r\n        if (ngDevMode) {\r\n            prevInjectContext = setInjectorProfilerContext({ injector: this, token: null });\r\n        }\r\n        try {\r\n            const initializers = this.get(ENVIRONMENT_INITIALIZER, EMPTY_ARRAY, { self: true });\r\n            if (ngDevMode && !Array.isArray(initializers)) {\r\n                throw new RuntimeError(-209 /* RuntimeErrorCode.INVALID_MULTI_PROVIDER */, 'Unexpected type of the `ENVIRONMENT_INITIALIZER` token value ' +\r\n                    `(expected an array, but got ${typeof initializers}). ` +\r\n                    'Please check that the `ENVIRONMENT_INITIALIZER` token is configured as a ' +\r\n                    '`multi: true` provider.');\r\n            }\r\n            for (const initializer of initializers) {\r\n                initializer();\r\n            }\r\n        }\r\n        finally {\r\n            setCurrentInjector(previousInjector);\r\n            setInjectImplementation(previousInjectImplementation);\r\n            ngDevMode && setInjectorProfilerContext(prevInjectContext);\r\n            setActiveConsumer(prevConsumer);\r\n        }\r\n    }\r\n    toString() {\r\n        const tokens = [];\r\n        const records = this.records;\r\n        for (const token of records.keys()) {\r\n            tokens.push(stringify(token));\r\n        }\r\n        return `R3Injector[${tokens.join(', ')}]`;\r\n    }\r\n    /**\r\n     * Process a `SingleProvider` and add it.\r\n     */\r\n    processProvider(provider) {\r\n        // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\r\n        // property.\r\n        provider = resolveForwardRef(provider);\r\n        let token = isTypeProvider(provider)\r\n            ? provider\r\n            : resolveForwardRef(provider && provider.provide);\r\n        // Construct a `Record` for the provider.\r\n        const record = providerToRecord(provider);\r\n        if (ngDevMode) {\r\n            runInInjectorProfilerContext(this, token, () => {\r\n                // Emit InjectorProfilerEventType.Create if provider is a value provider because\r\n                // these are the only providers that do not go through the value hydration logic\r\n                // where this event would normally be emitted from.\r\n                if (isValueProvider(provider)) {\r\n                    emitInjectorToCreateInstanceEvent(token);\r\n                    emitInstanceCreatedByInjectorEvent(provider.useValue);\r\n                }\r\n                emitProviderConfiguredEvent(provider);\r\n            });\r\n        }\r\n        if (!isTypeProvider(provider) && provider.multi === true) {\r\n            // If the provider indicates that it's a multi-provider, process it specially.\r\n            // First check whether it's been defined already.\r\n            let multiRecord = this.records.get(token);\r\n            if (multiRecord) {\r\n                // It has. Throw a nice error if\r\n                if (ngDevMode && multiRecord.multi === undefined) {\r\n                    throwMixedMultiProviderError();\r\n                }\r\n            }\r\n            else {\r\n                multiRecord = makeRecord(undefined, NOT_YET, true);\r\n                multiRecord.factory = () => injectArgs(multiRecord.multi);\r\n                this.records.set(token, multiRecord);\r\n            }\r\n            token = provider;\r\n            multiRecord.multi.push(provider);\r\n        }\r\n        else {\r\n            if (ngDevMode) {\r\n                const existing = this.records.get(token);\r\n                if (existing && existing.multi !== undefined) {\r\n                    throwMixedMultiProviderError();\r\n                }\r\n            }\r\n        }\r\n        this.records.set(token, record);\r\n    }\r\n    hydrate(token, record, flags) {\r\n        const prevConsumer = setActiveConsumer(null);\r\n        try {\r\n            if (record.value === CIRCULAR) {\r\n                throw cyclicDependencyError(stringify(token));\r\n            }\r\n            else if (record.value === NOT_YET) {\r\n                record.value = CIRCULAR;\r\n                if (ngDevMode) {\r\n                    runInInjectorProfilerContext(this, token, () => {\r\n                        emitInjectorToCreateInstanceEvent(token);\r\n                        record.value = record.factory(undefined, flags);\r\n                        emitInstanceCreatedByInjectorEvent(record.value);\r\n                    });\r\n                }\r\n                else {\r\n                    record.value = record.factory(undefined, flags);\r\n                }\r\n            }\r\n            if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\r\n                this._ngOnDestroyHooks.add(record.value);\r\n            }\r\n            return record.value;\r\n        }\r\n        finally {\r\n            setActiveConsumer(prevConsumer);\r\n        }\r\n    }\r\n    injectableDefInScope(def) {\r\n        if (!def.providedIn) {\r\n            return false;\r\n        }\r\n        const providedIn = resolveForwardRef(def.providedIn);\r\n        if (typeof providedIn === 'string') {\r\n            return providedIn === 'any' || this.scopes.has(providedIn);\r\n        }\r\n        else {\r\n            return this.injectorDefTypes.has(providedIn);\r\n        }\r\n    }\r\n    removeOnDestroy(callback) {\r\n        const destroyCBIdx = this._onDestroyHooks.indexOf(callback);\r\n        if (destroyCBIdx !== -1) {\r\n            this._onDestroyHooks.splice(destroyCBIdx, 1);\r\n        }\r\n    }\r\n}\r\nfunction injectableDefOrInjectorDefFactory(token) {\r\n    // Most tokens will have an injectable def directly on them, which specifies a factory directly.\r\n    const injectableDef = getInjectableDef(token);\r\n    const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);\r\n    if (factory !== null) {\r\n        return factory;\r\n    }\r\n    // InjectionTokens should have an injectable def (ɵprov) and thus should be handled above.\r\n    // If it's missing that, it's an error.\r\n    if (token instanceof InjectionToken) {\r\n        throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && `Token ${stringify(token)} is missing a ɵprov definition.`);\r\n    }\r\n    // Undecorated types can sometimes be created if they have no constructor arguments.\r\n    if (token instanceof Function) {\r\n        return getUndecoratedInjectableFactory(token);\r\n    }\r\n    // There was no way to resolve a factory for this token.\r\n    throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode && 'unreachable');\r\n}\r\nfunction getUndecoratedInjectableFactory(token) {\r\n    // If the token has parameters then it has dependencies that we cannot resolve implicitly.\r\n    const paramLength = token.length;\r\n    if (paramLength > 0) {\r\n        throw new RuntimeError(204 /* RuntimeErrorCode.INVALID_INJECTION_TOKEN */, ngDevMode &&\r\n            `Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength, '?').join(', ')}).`);\r\n    }\r\n    // The constructor function appears to have no parameters.\r\n    // This might be because it inherits from a super-class. In which case, use an injectable\r\n    // def from an ancestor if there is one.\r\n    // Otherwise this really is a simple class with no dependencies, so return a factory that\r\n    // just instantiates the zero-arg constructor.\r\n    const inheritedInjectableDef = getInheritedInjectableDef(token);\r\n    if (inheritedInjectableDef !== null) {\r\n        return () => inheritedInjectableDef.factory(token);\r\n    }\r\n    else {\r\n        return () => new token();\r\n    }\r\n}\r\nfunction providerToRecord(provider) {\r\n    if (isValueProvider(provider)) {\r\n        return makeRecord(undefined, provider.useValue);\r\n    }\r\n    else {\r\n        const factory = providerToFactory(provider);\r\n        return makeRecord(factory, NOT_YET);\r\n    }\r\n}\r\n/**\r\n * Converts a `SingleProvider` into a factory function.\r\n *\r\n * @param provider provider to convert to factory\r\n */\r\nfunction providerToFactory(provider, ngModuleType, providers) {\r\n    let factory = undefined;\r\n    if (ngDevMode && isEnvironmentProviders(provider)) {\r\n        throwInvalidProviderError(undefined, providers, provider);\r\n    }\r\n    if (isTypeProvider(provider)) {\r\n        const unwrappedProvider = resolveForwardRef(provider);\r\n        return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);\r\n    }\r\n    else {\r\n        if (isValueProvider(provider)) {\r\n            factory = () => resolveForwardRef(provider.useValue);\r\n        }\r\n        else if (isFactoryProvider(provider)) {\r\n            factory = () => provider.useFactory(...injectArgs(provider.deps || []));\r\n        }\r\n        else if (isExistingProvider(provider)) {\r\n            factory = (_, flags) => ɵɵinject(resolveForwardRef(provider.useExisting), flags !== undefined && flags & 8 /* InternalInjectFlags.Optional */\r\n                ? 8 /* InternalInjectFlags.Optional */\r\n                : undefined);\r\n        }\r\n        else {\r\n            const classRef = resolveForwardRef(provider &&\r\n                (provider.useClass || provider.provide));\r\n            if (ngDevMode && !classRef) {\r\n                throwInvalidProviderError(ngModuleType, providers, provider);\r\n            }\r\n            if (hasDeps(provider)) {\r\n                factory = () => new classRef(...injectArgs(provider.deps));\r\n            }\r\n            else {\r\n                return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);\r\n            }\r\n        }\r\n    }\r\n    return factory;\r\n}\r\nfunction assertNotDestroyed(injector) {\r\n    if (injector.destroyed) {\r\n        throw new RuntimeError(205 /* RuntimeErrorCode.INJECTOR_ALREADY_DESTROYED */, ngDevMode && 'Injector has already been destroyed.');\r\n    }\r\n}\r\nfunction makeRecord(factory, value, multi = false) {\r\n    return {\r\n        factory: factory,\r\n        value: value,\r\n        multi: multi ? [] : undefined,\r\n    };\r\n}\r\nfunction hasDeps(value) {\r\n    return !!value.deps;\r\n}\r\nfunction hasOnDestroy(value) {\r\n    return (value !== null &&\r\n        typeof value === 'object' &&\r\n        typeof value.ngOnDestroy === 'function');\r\n}\r\nfunction couldBeInjectableType(value) {\r\n    return (typeof value === 'function' ||\r\n        (typeof value === 'object' && value.ngMetadataName === 'InjectionToken'));\r\n}\r\nfunction forEachSingleProvider(providers, fn) {\r\n    for (const provider of providers) {\r\n        if (Array.isArray(provider)) {\r\n            forEachSingleProvider(provider, fn);\r\n        }\r\n        else if (provider && isEnvironmentProviders(provider)) {\r\n            forEachSingleProvider(provider.ɵproviders, fn);\r\n        }\r\n        else {\r\n            fn(provider);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Runs the given function in the [context](guide/di/dependency-injection-context) of the given\r\n * `Injector`.\r\n *\r\n * Within the function's stack frame, [`inject`](api/core/inject) can be used to inject dependencies\r\n * from the given `Injector`. Note that `inject` is only usable synchronously, and cannot be used in\r\n * any asynchronous callbacks or after any `await` points.\r\n *\r\n * @param injector the injector which will satisfy calls to [`inject`](api/core/inject) while `fn`\r\n *     is executing\r\n * @param fn the closure to be run in the context of `injector`\r\n * @returns the return value of the function, if any\r\n * @publicApi\r\n */\r\nfunction runInInjectionContext(injector, fn) {\r\n    let internalInjector;\r\n    if (injector instanceof R3Injector) {\r\n        assertNotDestroyed(injector);\r\n        internalInjector = injector;\r\n    }\r\n    else {\r\n        internalInjector = new RetrievingInjector(injector);\r\n    }\r\n    let prevInjectorProfilerContext;\r\n    if (ngDevMode) {\r\n        prevInjectorProfilerContext = setInjectorProfilerContext({ injector, token: null });\r\n    }\r\n    const prevInjector = setCurrentInjector(internalInjector);\r\n    const previousInjectImplementation = setInjectImplementation(undefined);\r\n    try {\r\n        return fn();\r\n    }\r\n    finally {\r\n        setCurrentInjector(prevInjector);\r\n        ngDevMode && setInjectorProfilerContext(prevInjectorProfilerContext);\r\n        setInjectImplementation(previousInjectImplementation);\r\n    }\r\n}\r\n/**\r\n * Whether the current stack frame is inside an injection context.\r\n */\r\nfunction isInInjectionContext() {\r\n    return getInjectImplementation() !== undefined || getCurrentInjector() != null;\r\n}\r\n/**\r\n * Asserts that the current stack frame is within an [injection\r\n * context](guide/di/dependency-injection-context) and has access to `inject`.\r\n *\r\n * @param debugFn a reference to the function making the assertion (used for the error message).\r\n *\r\n * @publicApi\r\n */\r\nfunction assertInInjectionContext(debugFn) {\r\n    // Taking a `Function` instead of a string name here prevents the unminified name of the function\r\n    // from being retained in the bundle regardless of minification.\r\n    if (!isInInjectionContext()) {\r\n        throw new RuntimeError(-203 /* RuntimeErrorCode.MISSING_INJECTION_CONTEXT */, ngDevMode &&\r\n            debugFn.name +\r\n                '() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`');\r\n    }\r\n}\r\n\r\n// Below are constants for LView indices to help us look up LView members\r\n// without having to remember the specific indices.\r\n// Uglify will inline these when minifying so there shouldn't be a cost.\r\nconst HOST = 0;\r\nconst TVIEW = 1;\r\n// Shared with LContainer\r\nconst FLAGS = 2;\r\nconst PARENT = 3;\r\nconst NEXT = 4;\r\nconst T_HOST = 5;\r\n// End shared with LContainer\r\nconst HYDRATION = 6;\r\nconst CLEANUP = 7;\r\nconst CONTEXT = 8;\r\nconst INJECTOR = 9;\r\nconst ENVIRONMENT = 10;\r\nconst RENDERER = 11;\r\nconst CHILD_HEAD = 12;\r\nconst CHILD_TAIL = 13;\r\n// FIXME(misko): Investigate if the three declarations aren't all same thing.\r\nconst DECLARATION_VIEW = 14;\r\nconst DECLARATION_COMPONENT_VIEW = 15;\r\nconst DECLARATION_LCONTAINER = 16;\r\nconst PREORDER_HOOK_FLAGS = 17;\r\nconst QUERIES = 18;\r\nconst ID = 19;\r\nconst EMBEDDED_VIEW_INJECTOR = 20;\r\nconst ON_DESTROY_HOOKS = 21;\r\nconst EFFECTS_TO_SCHEDULE = 22;\r\nconst EFFECTS = 23;\r\nconst REACTIVE_TEMPLATE_CONSUMER = 24;\r\nconst AFTER_RENDER_SEQUENCES_TO_ADD = 25;\r\n/**\r\n * Size of LView's header. Necessary to adjust for it when setting slots.\r\n *\r\n * IMPORTANT: `HEADER_OFFSET` should only be referred to the in the `ɵɵ*` instructions to translate\r\n * instruction index into `LView` index. All other indexes should be in the `LView` index space and\r\n * there should be no need to refer to `HEADER_OFFSET` anywhere else.\r\n */\r\nconst HEADER_OFFSET = 26;\r\n\r\n/**\r\n * Special location which allows easy identification of type. If we have an array which was\r\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\r\n * `LContainer`.\r\n */\r\nconst TYPE = 1;\r\n/**\r\n * Below are constants for LContainer indices to help us look up LContainer members\r\n * without having to remember the specific indices.\r\n * Uglify will inline these when minifying so there shouldn't be a cost.\r\n */\r\n// FLAGS, PARENT, NEXT, and T_HOST are indices 2, 3, 4, and 5\r\n// As we already have these constants in LView, we don't need to re-create them.\r\nconst DEHYDRATED_VIEWS = 6;\r\nconst NATIVE = 7;\r\nconst VIEW_REFS = 8;\r\nconst MOVED_VIEWS = 9;\r\n/**\r\n * Size of LContainer's header. Represents the index after which all views in the\r\n * container will be inserted. We need to keep a record of current views so we know\r\n * which views are already in the DOM (and don't need to be re-added) and so we can\r\n * remove views from the DOM when they are no longer required.\r\n */\r\nconst CONTAINER_HEADER_OFFSET = 10;\r\n\r\n/**\r\n * True if `value` is `LView`.\r\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\r\n */\r\nfunction isLView(value) {\r\n    return Array.isArray(value) && typeof value[TYPE] === 'object';\r\n}\r\n/**\r\n * True if `value` is `LContainer`.\r\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\r\n */\r\nfunction isLContainer(value) {\r\n    return Array.isArray(value) && value[TYPE] === true;\r\n}\r\nfunction isContentQueryHost(tNode) {\r\n    return (tNode.flags & 4 /* TNodeFlags.hasContentQuery */) !== 0;\r\n}\r\nfunction isComponentHost(tNode) {\r\n    return tNode.componentOffset > -1;\r\n}\r\nfunction isDirectiveHost(tNode) {\r\n    return (tNode.flags & 1 /* TNodeFlags.isDirectiveHost */) === 1 /* TNodeFlags.isDirectiveHost */;\r\n}\r\nfunction isComponentDef(def) {\r\n    return !!def.template;\r\n}\r\nfunction isRootView(target) {\r\n    // Determines whether a given LView is marked as a root view.\r\n    return (target[FLAGS] & 512 /* LViewFlags.IsRoot */) !== 0;\r\n}\r\nfunction isProjectionTNode(tNode) {\r\n    return (tNode.type & 16 /* TNodeType.Projection */) === 16 /* TNodeType.Projection */;\r\n}\r\nfunction hasI18n(lView) {\r\n    return (lView[FLAGS] & 32 /* LViewFlags.HasI18n */) === 32 /* LViewFlags.HasI18n */;\r\n}\r\nfunction isDestroyed(lView) {\r\n    // Determines whether a given LView is marked as destroyed.\r\n    return (lView[FLAGS] & 256 /* LViewFlags.Destroyed */) === 256 /* LViewFlags.Destroyed */;\r\n}\r\n\r\n// [Assert functions do not constraint type when they are guarded by a truthy\r\n// expression.](https://github.com/microsoft/TypeScript/issues/37295)\r\nfunction assertTNodeForLView(tNode, lView) {\r\n    assertTNodeForTView(tNode, lView[TVIEW]);\r\n}\r\nfunction assertTNodeCreationIndex(lView, index) {\r\n    const adjustedIndex = index + HEADER_OFFSET;\r\n    assertIndexInRange(lView, adjustedIndex);\r\n    assertLessThan(adjustedIndex, lView[TVIEW].bindingStartIndex, 'TNodes should be created before any bindings');\r\n}\r\nfunction assertTNodeForTView(tNode, tView) {\r\n    assertTNode(tNode);\r\n    const tData = tView.data;\r\n    for (let i = HEADER_OFFSET; i < tData.length; i++) {\r\n        if (tData[i] === tNode) {\r\n            return;\r\n        }\r\n    }\r\n    throwError('This TNode does not belong to this TView.');\r\n}\r\nfunction assertTNode(tNode) {\r\n    assertDefined(tNode, 'TNode must be defined');\r\n    if (!(tNode && typeof tNode === 'object' && tNode.hasOwnProperty('directiveStylingLast'))) {\r\n        throwError('Not of type TNode, got: ' + tNode);\r\n    }\r\n}\r\nfunction assertTIcu(tIcu) {\r\n    assertDefined(tIcu, 'Expected TIcu to be defined');\r\n    if (!(typeof tIcu.currentCaseLViewIndex === 'number')) {\r\n        throwError('Object is not of TIcu type.');\r\n    }\r\n}\r\nfunction assertComponentType(actual, msg = \"Type passed in is not ComponentType, it does not have 'ɵcmp' property.\") {\r\n    if (!getComponentDef(actual)) {\r\n        throwError(msg);\r\n    }\r\n}\r\nfunction assertNgModuleType(actual, msg = \"Type passed in is not NgModuleType, it does not have 'ɵmod' property.\") {\r\n    if (!getNgModuleDef(actual)) {\r\n        throwError(msg);\r\n    }\r\n}\r\nfunction assertHasParent(tNode) {\r\n    assertDefined(tNode, 'currentTNode should exist!');\r\n    assertDefined(tNode.parent, 'currentTNode should have a parent');\r\n}\r\nfunction assertLContainer(value) {\r\n    assertDefined(value, 'LContainer must be defined');\r\n    assertEqual(isLContainer(value), true, 'Expecting LContainer');\r\n}\r\nfunction assertLViewOrUndefined(value) {\r\n    value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\r\n}\r\nfunction assertLView(value) {\r\n    assertDefined(value, 'LView must be defined');\r\n    assertEqual(isLView(value), true, 'Expecting LView');\r\n}\r\nfunction assertFirstCreatePass(tView, errMessage) {\r\n    assertEqual(tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');\r\n}\r\nfunction assertFirstUpdatePass(tView, errMessage) {\r\n    assertEqual(tView.firstUpdatePass, true, 'Should only be called in first update pass.');\r\n}\r\n/**\r\n * This is a basic sanity check that an object is probably a directive def. DirectiveDef is\r\n * an interface, so we can't do a direct instanceof check.\r\n */\r\nfunction assertDirectiveDef(obj) {\r\n    if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {\r\n        throwError(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);\r\n    }\r\n}\r\nfunction assertIndexInDeclRange(tView, index) {\r\n    assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);\r\n}\r\nfunction assertIndexInExpandoRange(lView, index) {\r\n    const tView = lView[1];\r\n    assertBetween(tView.expandoStartIndex, lView.length, index);\r\n}\r\nfunction assertBetween(lower, upper, index) {\r\n    if (!(lower <= index && index < upper)) {\r\n        throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);\r\n    }\r\n}\r\nfunction assertProjectionSlots(lView, errMessage) {\r\n    assertDefined(lView[DECLARATION_COMPONENT_VIEW], 'Component views should exist.');\r\n    assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, 'Components with projection nodes (<ng-content>) must have projection slots defined.');\r\n}\r\nfunction assertParentView(lView, errMessage) {\r\n    assertDefined(lView, \"Component views should always have a parent view (component's host view)\");\r\n}\r\n/**\r\n * This is a basic sanity check that the `injectorIndex` seems to point to what looks like a\r\n * NodeInjector data structure.\r\n *\r\n * @param lView `LView` which should be checked.\r\n * @param injectorIndex index into the `LView` where the `NodeInjector` is expected.\r\n */\r\nfunction assertNodeInjector(lView, injectorIndex) {\r\n    assertIndexInExpandoRange(lView, injectorIndex);\r\n    assertIndexInExpandoRange(lView, injectorIndex + 8 /* NodeInjectorOffset.PARENT */);\r\n    assertNumber(lView[injectorIndex + 0], 'injectorIndex should point to a bloom filter');\r\n    assertNumber(lView[injectorIndex + 1], 'injectorIndex should point to a bloom filter');\r\n    assertNumber(lView[injectorIndex + 2], 'injectorIndex should point to a bloom filter');\r\n    assertNumber(lView[injectorIndex + 3], 'injectorIndex should point to a bloom filter');\r\n    assertNumber(lView[injectorIndex + 4], 'injectorIndex should point to a bloom filter');\r\n    assertNumber(lView[injectorIndex + 5], 'injectorIndex should point to a bloom filter');\r\n    assertNumber(lView[injectorIndex + 6], 'injectorIndex should point to a bloom filter');\r\n    assertNumber(lView[injectorIndex + 7], 'injectorIndex should point to a bloom filter');\r\n    assertNumber(lView[injectorIndex + 8 /* NodeInjectorOffset.PARENT */], 'injectorIndex should point to parent injector');\r\n}\r\n\r\nconst SVG_NAMESPACE = 'svg';\r\nconst MATH_ML_NAMESPACE = 'math';\r\n\r\n/**\r\n * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)\r\n * in same location in `LView`. This is because we don't want to pre-allocate space for it\r\n * because the storage is sparse. This file contains utilities for dealing with such data types.\r\n *\r\n * How do we know what is stored at a given location in `LView`.\r\n * - `Array.isArray(value) === false` => `RNode` (The normal storage value)\r\n * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.\r\n *   - `typeof value[TYPE] === 'object'` => `LView`\r\n *      - This happens when we have a component at a given location\r\n *   - `typeof value[TYPE] === true` => `LContainer`\r\n *      - This happens when we have `LContainer` binding at a given location.\r\n *\r\n *\r\n * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.\r\n */\r\n/**\r\n * Returns `RNode`.\r\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\r\n */\r\nfunction unwrapRNode(value) {\r\n    while (Array.isArray(value)) {\r\n        value = value[HOST];\r\n    }\r\n    return value;\r\n}\r\n/**\r\n * Returns `LView` or `null` if not found.\r\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\r\n */\r\nfunction unwrapLView(value) {\r\n    while (Array.isArray(value)) {\r\n        // This check is same as `isLView()` but we don't call at as we don't want to call\r\n        // `Array.isArray()` twice and give JITer more work for inlining.\r\n        if (typeof value[TYPE] === 'object')\r\n            return value;\r\n        value = value[HOST];\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Retrieves an element value from the provided `viewData`, by unwrapping\r\n * from any containers, component views, or style contexts.\r\n */\r\nfunction getNativeByIndex(index, lView) {\r\n    ngDevMode && assertIndexInRange(lView, index);\r\n    ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Expected to be past HEADER_OFFSET');\r\n    return unwrapRNode(lView[index]);\r\n}\r\n/**\r\n * Retrieve an `RNode` for a given `TNode` and `LView`.\r\n *\r\n * This function guarantees in dev mode to retrieve a non-null `RNode`.\r\n *\r\n * @param tNode\r\n * @param lView\r\n */\r\nfunction getNativeByTNode(tNode, lView) {\r\n    ngDevMode && assertTNodeForLView(tNode, lView);\r\n    ngDevMode && assertIndexInRange(lView, tNode.index);\r\n    const node = unwrapRNode(lView[tNode.index]);\r\n    return node;\r\n}\r\n/**\r\n * Retrieve an `RNode` or `null` for a given `TNode` and `LView`.\r\n *\r\n * Some `TNode`s don't have associated `RNode`s. For example `Projection`\r\n *\r\n * @param tNode\r\n * @param lView\r\n */\r\nfunction getNativeByTNodeOrNull(tNode, lView) {\r\n    const index = tNode === null ? -1 : tNode.index;\r\n    if (index !== -1) {\r\n        ngDevMode && assertTNodeForLView(tNode, lView);\r\n        const node = unwrapRNode(lView[index]);\r\n        return node;\r\n    }\r\n    return null;\r\n}\r\n// fixme(misko): The return Type should be `TNode|null`\r\nfunction getTNode(tView, index) {\r\n    ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\r\n    ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');\r\n    const tNode = tView.data[index];\r\n    ngDevMode && tNode !== null && assertTNode(tNode);\r\n    return tNode;\r\n}\r\n/** Retrieves a value from any `LView` or `TData`. */\r\nfunction load(view, index) {\r\n    ngDevMode && assertIndexInRange(view, index);\r\n    return view[index];\r\n}\r\n/** Store a value in the `data` at a given `index`. */\r\nfunction store(tView, lView, index, value) {\r\n    // We don't store any static data for local variables, so the first time\r\n    // we see the template, we should store as null to avoid a sparse array\r\n    if (index >= tView.data.length) {\r\n        tView.data[index] = null;\r\n        tView.blueprint[index] = null;\r\n    }\r\n    lView[index] = value;\r\n}\r\nfunction getComponentLViewByIndex(nodeIndex, hostView) {\r\n    // Could be an LView or an LContainer. If LContainer, unwrap to find LView.\r\n    ngDevMode && assertIndexInRange(hostView, nodeIndex);\r\n    const slotValue = hostView[nodeIndex];\r\n    const lView = isLView(slotValue) ? slotValue : slotValue[HOST];\r\n    return lView;\r\n}\r\n/** Checks whether a given view is in creation mode */\r\nfunction isCreationMode(view) {\r\n    return (view[FLAGS] & 4 /* LViewFlags.CreationMode */) === 4 /* LViewFlags.CreationMode */;\r\n}\r\n/**\r\n * Returns a boolean for whether the view is attached to the change detection tree.\r\n *\r\n * Note: This determines whether a view should be checked, not whether it's inserted\r\n * into a container. For that, you'll want `viewAttachedToContainer` below.\r\n */\r\nfunction viewAttachedToChangeDetector(view) {\r\n    return (view[FLAGS] & 128 /* LViewFlags.Attached */) === 128 /* LViewFlags.Attached */;\r\n}\r\n/** Returns a boolean for whether the view is attached to a container. */\r\nfunction viewAttachedToContainer(view) {\r\n    return isLContainer(view[PARENT]);\r\n}\r\nfunction getConstant(consts, index) {\r\n    if (index === null || index === undefined)\r\n        return null;\r\n    ngDevMode && assertIndexInRange(consts, index);\r\n    return consts[index];\r\n}\r\n/**\r\n * Resets the pre-order hook flags of the view.\r\n * @param lView the LView on which the flags are reset\r\n */\r\nfunction resetPreOrderHookFlags(lView) {\r\n    lView[PREORDER_HOOK_FLAGS] = 0;\r\n}\r\n/**\r\n * Adds the `RefreshView` flag from the lView and updates HAS_CHILD_VIEWS_TO_REFRESH flag of\r\n * parents.\r\n */\r\nfunction markViewForRefresh(lView) {\r\n    if (lView[FLAGS] & 1024 /* LViewFlags.RefreshView */) {\r\n        return;\r\n    }\r\n    lView[FLAGS] |= 1024 /* LViewFlags.RefreshView */;\r\n    if (viewAttachedToChangeDetector(lView)) {\r\n        markAncestorsForTraversal(lView);\r\n    }\r\n}\r\n/**\r\n * Walks up the LView hierarchy.\r\n * @param nestingLevel Number of times to walk up in hierarchy.\r\n * @param currentView View from which to start the lookup.\r\n */\r\nfunction walkUpViews(nestingLevel, currentView) {\r\n    while (nestingLevel > 0) {\r\n        ngDevMode &&\r\n            assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');\r\n        currentView = currentView[DECLARATION_VIEW];\r\n        nestingLevel--;\r\n    }\r\n    return currentView;\r\n}\r\nfunction requiresRefreshOrTraversal(lView) {\r\n    return !!(lView[FLAGS] & (1024 /* LViewFlags.RefreshView */ | 8192 /* LViewFlags.HasChildViewsToRefresh */) ||\r\n        lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty);\r\n}\r\n/**\r\n * Updates the `HasChildViewsToRefresh` flag on the parents of the `LView` as well as the\r\n * parents above.\r\n */\r\nfunction updateAncestorTraversalFlagsOnAttach(lView) {\r\n    lView[ENVIRONMENT].changeDetectionScheduler?.notify(8 /* NotificationSource.ViewAttached */);\r\n    if (lView[FLAGS] & 64 /* LViewFlags.Dirty */) {\r\n        lView[FLAGS] |= 1024 /* LViewFlags.RefreshView */;\r\n    }\r\n    if (requiresRefreshOrTraversal(lView)) {\r\n        markAncestorsForTraversal(lView);\r\n    }\r\n}\r\n/**\r\n * Ensures views above the given `lView` are traversed during change detection even when they are\r\n * not dirty.\r\n *\r\n * This is done by setting the `HAS_CHILD_VIEWS_TO_REFRESH` flag up to the root, stopping when the\r\n * flag is already `true` or the `lView` is detached.\r\n */\r\nfunction markAncestorsForTraversal(lView) {\r\n    lView[ENVIRONMENT].changeDetectionScheduler?.notify(0 /* NotificationSource.MarkAncestorsForTraversal */);\r\n    let parent = getLViewParent(lView);\r\n    while (parent !== null) {\r\n        // We stop adding markers to the ancestors once we reach one that already has the marker. This\r\n        // is to avoid needlessly traversing all the way to the root when the marker already exists.\r\n        if (parent[FLAGS] & 8192 /* LViewFlags.HasChildViewsToRefresh */) {\r\n            break;\r\n        }\r\n        parent[FLAGS] |= 8192 /* LViewFlags.HasChildViewsToRefresh */;\r\n        if (!viewAttachedToChangeDetector(parent)) {\r\n            break;\r\n        }\r\n        parent = getLViewParent(parent);\r\n    }\r\n}\r\n/**\r\n * Stores a LView-specific destroy callback.\r\n */\r\nfunction storeLViewOnDestroy(lView, onDestroyCallback) {\r\n    if (isDestroyed(lView)) {\r\n        throw new RuntimeError(911 /* RuntimeErrorCode.VIEW_ALREADY_DESTROYED */, ngDevMode && 'View has already been destroyed.');\r\n    }\r\n    if (lView[ON_DESTROY_HOOKS] === null) {\r\n        lView[ON_DESTROY_HOOKS] = [];\r\n    }\r\n    lView[ON_DESTROY_HOOKS].push(onDestroyCallback);\r\n}\r\n/**\r\n * Removes previously registered LView-specific destroy callback.\r\n */\r\nfunction removeLViewOnDestroy(lView, onDestroyCallback) {\r\n    if (lView[ON_DESTROY_HOOKS] === null)\r\n        return;\r\n    const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);\r\n    if (destroyCBIdx !== -1) {\r\n        lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);\r\n    }\r\n}\r\n/**\r\n * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of\r\n * that LContainer, which is an LView\r\n * @param lView the lView whose parent to get\r\n */\r\nfunction getLViewParent(lView) {\r\n    ngDevMode && assertLView(lView);\r\n    const parent = lView[PARENT];\r\n    return isLContainer(parent) ? parent[PARENT] : parent;\r\n}\r\nfunction getOrCreateLViewCleanup(view) {\r\n    // top level variables should not be exported for performance reasons (PERF_NOTES.md)\r\n    return (view[CLEANUP] ??= []);\r\n}\r\nfunction getOrCreateTViewCleanup(tView) {\r\n    return (tView.cleanup ??= []);\r\n}\r\n/**\r\n * Saves context for this cleanup function in LView.cleanupInstances.\r\n *\r\n * On the first template pass, saves in TView:\r\n * - Cleanup function\r\n * - Index of context we just saved in LView.cleanupInstances\r\n */\r\nfunction storeCleanupWithContext(tView, lView, context, cleanupFn) {\r\n    const lCleanup = getOrCreateLViewCleanup(lView);\r\n    // Historically the `storeCleanupWithContext` was used to register both framework-level and\r\n    // user-defined cleanup callbacks, but over time those two types of cleanups were separated.\r\n    // This dev mode checks assures that user-level cleanup callbacks are _not_ stored in data\r\n    // structures reserved for framework-specific hooks.\r\n    ngDevMode &&\r\n        assertDefined(context, 'Cleanup context is mandatory when registering framework-level destroy hooks');\r\n    lCleanup.push(context);\r\n    if (tView.firstCreatePass) {\r\n        getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);\r\n    }\r\n    else {\r\n        // Make sure that no new framework-level cleanup functions are registered after the first\r\n        // template pass is done (and TView data structures are meant to fully constructed).\r\n        if (ngDevMode) {\r\n            Object.freeze(getOrCreateTViewCleanup(tView));\r\n        }\r\n    }\r\n}\r\n\r\nconst instructionState = {\r\n    lFrame: createLFrame(null),\r\n    bindingsEnabled: true,\r\n    skipHydrationRootTNode: null,\r\n};\r\nvar CheckNoChangesMode;\r\n(function (CheckNoChangesMode) {\r\n    CheckNoChangesMode[CheckNoChangesMode[\"Off\"] = 0] = \"Off\";\r\n    CheckNoChangesMode[CheckNoChangesMode[\"Exhaustive\"] = 1] = \"Exhaustive\";\r\n    CheckNoChangesMode[CheckNoChangesMode[\"OnlyDirtyViews\"] = 2] = \"OnlyDirtyViews\";\r\n})(CheckNoChangesMode || (CheckNoChangesMode = {}));\r\n/**\r\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\r\n *\r\n * Necessary to support ChangeDetectorRef.checkNoChanges().\r\n *\r\n * The `checkNoChanges` function is invoked only in ngDevMode=true and verifies that no unintended\r\n * changes exist in the change detector or its children.\r\n */\r\nlet _checkNoChangesMode = 0; /* CheckNoChangesMode.Off */\r\n/**\r\n * Flag used to indicate that we are in the middle running change detection on a view\r\n *\r\n * @see detectChangesInViewWhileDirty\r\n */\r\nlet _isRefreshingViews = false;\r\nfunction getElementDepthCount() {\r\n    return instructionState.lFrame.elementDepthCount;\r\n}\r\nfunction increaseElementDepthCount() {\r\n    instructionState.lFrame.elementDepthCount++;\r\n}\r\nfunction decreaseElementDepthCount() {\r\n    instructionState.lFrame.elementDepthCount--;\r\n}\r\nfunction getBindingsEnabled() {\r\n    return instructionState.bindingsEnabled;\r\n}\r\n/**\r\n * Returns true if currently inside a skip hydration block.\r\n * @returns boolean\r\n */\r\nfunction isInSkipHydrationBlock() {\r\n    return instructionState.skipHydrationRootTNode !== null;\r\n}\r\n/**\r\n * Returns true if this is the root TNode of the skip hydration block.\r\n * @param tNode the current TNode\r\n * @returns boolean\r\n */\r\nfunction isSkipHydrationRootTNode(tNode) {\r\n    return instructionState.skipHydrationRootTNode === tNode;\r\n}\r\n/**\r\n * Enables directive matching on elements.\r\n *\r\n *  * Example:\r\n * ```html\r\n * <my-comp my-directive>\r\n *   Should match component / directive.\r\n * </my-comp>\r\n * <div ngNonBindable>\r\n *   <!-- ɵɵdisableBindings() -->\r\n *   <my-comp my-directive>\r\n *     Should not match component / directive because we are in ngNonBindable.\r\n *   </my-comp>\r\n *   <!-- ɵɵenableBindings() -->\r\n * </div>\r\n * ```\r\n *\r\n * @codeGenApi\r\n */\r\nfunction ɵɵenableBindings() {\r\n    instructionState.bindingsEnabled = true;\r\n}\r\n/**\r\n * Sets a flag to specify that the TNode is in a skip hydration block.\r\n * @param tNode the current TNode\r\n */\r\nfunction enterSkipHydrationBlock(tNode) {\r\n    instructionState.skipHydrationRootTNode = tNode;\r\n}\r\n/**\r\n * Disables directive matching on element.\r\n *\r\n *  * Example:\r\n * ```html\r\n * <my-comp my-directive>\r\n *   Should match component / directive.\r\n * </my-comp>\r\n * <div ngNonBindable>\r\n *   <!-- ɵɵdisableBindings() -->\r\n *   <my-comp my-directive>\r\n *     Should not match component / directive because we are in ngNonBindable.\r\n *   </my-comp>\r\n *   <!-- ɵɵenableBindings() -->\r\n * </div>\r\n * ```\r\n *\r\n * @codeGenApi\r\n */\r\nfunction ɵɵdisableBindings() {\r\n    instructionState.bindingsEnabled = false;\r\n}\r\n/**\r\n * Clears the root skip hydration node when leaving a skip hydration block.\r\n */\r\nfunction leaveSkipHydrationBlock() {\r\n    instructionState.skipHydrationRootTNode = null;\r\n}\r\n/**\r\n * Return the current `LView`.\r\n */\r\nfunction getLView() {\r\n    return instructionState.lFrame.lView;\r\n}\r\n/**\r\n * Return the current `TView`.\r\n */\r\nfunction getTView() {\r\n    return instructionState.lFrame.tView;\r\n}\r\n/**\r\n * Restores `contextViewData` to the given OpaqueViewState instance.\r\n *\r\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\r\n * of the current view and restore it when listeners are invoked. This allows\r\n * walking the declaration view tree in listeners to get vars from parent views.\r\n *\r\n * @param viewToRestore The OpaqueViewState instance to restore.\r\n * @returns Context of the restored OpaqueViewState instance.\r\n *\r\n * @codeGenApi\r\n */\r\nfunction ɵɵrestoreView(viewToRestore) {\r\n    instructionState.lFrame.contextLView = viewToRestore;\r\n    return viewToRestore[CONTEXT];\r\n}\r\n/**\r\n * Clears the view set in `ɵɵrestoreView` from memory. Returns the passed in\r\n * value so that it can be used as a return value of an instruction.\r\n *\r\n * @codeGenApi\r\n */\r\nfunction ɵɵresetView(value) {\r\n    instructionState.lFrame.contextLView = null;\r\n    return value;\r\n}\r\nfunction getCurrentTNode() {\r\n    let currentTNode = getCurrentTNodePlaceholderOk();\r\n    while (currentTNode !== null && currentTNode.type === 64 /* TNodeType.Placeholder */) {\r\n        currentTNode = currentTNode.parent;\r\n    }\r\n    return currentTNode;\r\n}\r\nfunction getCurrentTNodePlaceholderOk() {\r\n    return instructionState.lFrame.currentTNode;\r\n}\r\nfunction getCurrentParentTNode() {\r\n    const lFrame = instructionState.lFrame;\r\n    const currentTNode = lFrame.currentTNode;\r\n    return lFrame.isParent ? currentTNode : currentTNode.parent;\r\n}\r\nfunction setCurrentTNode(tNode, isParent) {\r\n    ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);\r\n    const lFrame = instructionState.lFrame;\r\n    lFrame.currentTNode = tNode;\r\n    lFrame.isParent = isParent;\r\n}\r\nfunction isCurrentTNodeParent() {\r\n    return instructionState.lFrame.isParent;\r\n}\r\nfunction setCurrentTNodeAsNotParent() {\r\n    instructionState.lFrame.isParent = false;\r\n}\r\nfunction getContextLView() {\r\n    const contextLView = instructionState.lFrame.contextLView;\r\n    ngDevMode && assertDefined(contextLView, 'contextLView must be defined.');\r\n    return contextLView;\r\n}\r\nfunction isInCheckNoChangesMode() {\r\n    !ngDevMode && throwError('Must never be called in production mode');\r\n    return _checkNoChangesMode !== CheckNoChangesMode.Off;\r\n}\r\nfunction isExhaustiveCheckNoChanges() {\r\n    !ngDevMode && throwError('Must never be called in production mode');\r\n    return _checkNoChangesMode === CheckNoChangesMode.Exhaustive;\r\n}\r\nfunction setIsInCheckNoChangesMode(mode) {\r\n    !ngDevMode && throwError('Must never be called in production mode');\r\n    _checkNoChangesMode = mode;\r\n}\r\nfunction isRefreshingViews() {\r\n    return _isRefreshingViews;\r\n}\r\nfunction setIsRefreshingViews(mode) {\r\n    const prev = _isRefreshingViews;\r\n    _isRefreshingViews = mode;\r\n    return prev;\r\n}\r\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\r\nfunction getBindingRoot() {\r\n    const lFrame = instructionState.lFrame;\r\n    let index = lFrame.bindingRootIndex;\r\n    if (index === -1) {\r\n        index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;\r\n    }\r\n    return index;\r\n}\r\nfunction getBindingIndex() {\r\n    return instructionState.lFrame.bindingIndex;\r\n}\r\nfunction setBindingIndex(value) {\r\n    return (instructionState.lFrame.bindingIndex = value);\r\n}\r\nfunction nextBindingIndex() {\r\n    return instructionState.lFrame.bindingIndex++;\r\n}\r\nfunction incrementBindingIndex(count) {\r\n    const lFrame = instructionState.lFrame;\r\n    const index = lFrame.bindingIndex;\r\n    lFrame.bindingIndex = lFrame.bindingIndex + count;\r\n    return index;\r\n}\r\nfunction isInI18nBlock() {\r\n    return instructionState.lFrame.inI18n;\r\n}\r\nfunction setInI18nBlock(isInI18nBlock) {\r\n    instructionState.lFrame.inI18n = isInI18nBlock;\r\n}\r\n/**\r\n * Set a new binding root index so that host template functions can execute.\r\n *\r\n * Bindings inside the host template are 0 index. But because we don't know ahead of time\r\n * how many host bindings we have we can't pre-compute them. For this reason they are all\r\n * 0 index and we just shift the root so that they match next available location in the LView.\r\n *\r\n * @param bindingRootIndex Root index for `hostBindings`\r\n * @param currentDirectiveIndex `TData[currentDirectiveIndex]` will point to the current directive\r\n *        whose `hostBindings` are being processed.\r\n */\r\nfunction setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {\r\n    const lFrame = instructionState.lFrame;\r\n    lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;\r\n    setCurrentDirectiveIndex(currentDirectiveIndex);\r\n}\r\n/**\r\n * When host binding is executing this points to the directive index.\r\n * `TView.data[getCurrentDirectiveIndex()]` is `DirectiveDef`\r\n * `LView[getCurrentDirectiveIndex()]` is directive instance.\r\n */\r\nfunction getCurrentDirectiveIndex() {\r\n    return instructionState.lFrame.currentDirectiveIndex;\r\n}\r\n/**\r\n * Sets an index of a directive whose `hostBindings` are being processed.\r\n *\r\n * @param currentDirectiveIndex `TData` index where current directive instance can be found.\r\n */\r\nfunction setCurrentDirectiveIndex(currentDirectiveIndex) {\r\n    instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;\r\n}\r\n/**\r\n * Retrieve the current `DirectiveDef` which is active when `hostBindings` instruction is being\r\n * executed.\r\n *\r\n * @param tData Current `TData` where the `DirectiveDef` will be looked up at.\r\n */\r\nfunction getCurrentDirectiveDef(tData) {\r\n    const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;\r\n    return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];\r\n}\r\nfunction getCurrentQueryIndex() {\r\n    return instructionState.lFrame.currentQueryIndex;\r\n}\r\nfunction setCurrentQueryIndex(value) {\r\n    instructionState.lFrame.currentQueryIndex = value;\r\n}\r\n/**\r\n * Returns a `TNode` of the location where the current `LView` is declared at.\r\n *\r\n * @param lView an `LView` that we want to find parent `TNode` for.\r\n */\r\nfunction getDeclarationTNode(lView) {\r\n    const tView = lView[TVIEW];\r\n    // Return the declaration parent for embedded views\r\n    if (tView.type === 2 /* TViewType.Embedded */) {\r\n        ngDevMode && assertDefined(tView.declTNode, 'Embedded TNodes should have declaration parents.');\r\n        return tView.declTNode;\r\n    }\r\n    // Components don't have `TView.declTNode` because each instance of component could be\r\n    // inserted in different location, hence `TView.declTNode` is meaningless.\r\n    // Falling back to `T_HOST` in case we cross component boundary.\r\n    if (tView.type === 1 /* TViewType.Component */) {\r\n        return lView[T_HOST];\r\n    }\r\n    // Remaining TNode type is `TViewType.Root` which doesn't have a parent TNode.\r\n    return null;\r\n}\r\n/**\r\n * This is a light weight version of the `enterView` which is needed by the DI system.\r\n *\r\n * @param lView `LView` location of the DI context.\r\n * @param tNode `TNode` for DI context\r\n * @param flags DI context flags. if `SkipSelf` flag is set than we walk up the declaration\r\n *     tree from `tNode`  until we find parent declared `TElementNode`.\r\n * @returns `true` if we have successfully entered DI associated with `tNode` (or with declared\r\n *     `TNode` if `flags` has  `SkipSelf`). Failing to enter DI implies that no associated\r\n *     `NodeInjector` can be found and we should instead use `ModuleInjector`.\r\n *     - If `true` than this call must be fallowed by `leaveDI`\r\n *     - If `false` than this call failed and we should NOT call `leaveDI`\r\n */\r\nfunction enterDI(lView, tNode, flags) {\r\n    ngDevMode && assertLViewOrUndefined(lView);\r\n    if (flags & 4 /* InternalInjectFlags.SkipSelf */) {\r\n        ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);\r\n        let parentTNode = tNode;\r\n        let parentLView = lView;\r\n        while (true) {\r\n            ngDevMode && assertDefined(parentTNode, 'Parent TNode should be defined');\r\n            parentTNode = parentTNode.parent;\r\n            if (parentTNode === null && !(flags & 1 /* InternalInjectFlags.Host */)) {\r\n                parentTNode = getDeclarationTNode(parentLView);\r\n                if (parentTNode === null)\r\n                    break;\r\n                // In this case, a parent exists and is definitely an element. So it will definitely\r\n                // have an existing lView as the declaration view, which is why we can assume it's defined.\r\n                ngDevMode && assertDefined(parentLView, 'Parent LView should be defined');\r\n                parentLView = parentLView[DECLARATION_VIEW];\r\n                // In Ivy there are Comment nodes that correspond to ngIf and NgFor embedded directives\r\n                // We want to skip those and look only at Elements and ElementContainers to ensure\r\n                // we're looking at true parent nodes, and not content or other types.\r\n                if (parentTNode.type & (2 /* TNodeType.Element */ | 8 /* TNodeType.ElementContainer */)) {\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        if (parentTNode === null) {\r\n            // If we failed to find a parent TNode this means that we should use module injector.\r\n            return false;\r\n        }\r\n        else {\r\n            tNode = parentTNode;\r\n            lView = parentLView;\r\n        }\r\n    }\r\n    ngDevMode && assertTNodeForLView(tNode, lView);\r\n    const lFrame = (instructionState.lFrame = allocLFrame());\r\n    lFrame.currentTNode = tNode;\r\n    lFrame.lView = lView;\r\n    return true;\r\n}\r\n/**\r\n * Swap the current lView with a new lView.\r\n *\r\n * For performance reasons we store the lView in the top level of the module.\r\n * This way we minimize the number of properties to read. Whenever a new view\r\n * is entered we have to store the lView for later, and when the view is\r\n * exited the state has to be restored\r\n *\r\n * @param newView New lView to become active\r\n * @returns the previously active lView;\r\n */\r\nfunction enterView(newView) {\r\n    ngDevMode && assertNotEqual(newView[0], newView[1], '????');\r\n    ngDevMode && assertLViewOrUndefined(newView);\r\n    const newLFrame = allocLFrame();\r\n    if (ngDevMode) {\r\n        assertEqual(newLFrame.isParent, true, 'Expected clean LFrame');\r\n        assertEqual(newLFrame.lView, null, 'Expected clean LFrame');\r\n        assertEqual(newLFrame.tView, null, 'Expected clean LFrame');\r\n        assertEqual(newLFrame.selectedIndex, -1, 'Expected clean LFrame');\r\n        assertEqual(newLFrame.elementDepthCount, 0, 'Expected clean LFrame');\r\n        assertEqual(newLFrame.currentDirectiveIndex, -1, 'Expected clean LFrame');\r\n        assertEqual(newLFrame.currentNamespace, null, 'Expected clean LFrame');\r\n        assertEqual(newLFrame.bindingRootIndex, -1, 'Expected clean LFrame');\r\n        assertEqual(newLFrame.currentQueryIndex, 0, 'Expected clean LFrame');\r\n    }\r\n    const tView = newView[TVIEW];\r\n    instructionState.lFrame = newLFrame;\r\n    ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);\r\n    newLFrame.currentTNode = tView.firstChild;\r\n    newLFrame.lView = newView;\r\n    newLFrame.tView = tView;\r\n    newLFrame.contextLView = newView;\r\n    newLFrame.bindingIndex = tView.bindingStartIndex;\r\n    newLFrame.inI18n = false;\r\n}\r\n/**\r\n * Allocates next free LFrame. This function tries to reuse the `LFrame`s to lower memory pressure.\r\n */\r\nfunction allocLFrame() {\r\n    const currentLFrame = instructionState.lFrame;\r\n    const childLFrame = currentLFrame === null ? null : currentLFrame.child;\r\n    const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;\r\n    return newLFrame;\r\n}\r\nfunction createLFrame(parent) {\r\n    const lFrame = {\r\n        currentTNode: null,\r\n        isParent: true,\r\n        lView: null,\r\n        tView: null,\r\n        selectedIndex: -1,\r\n        contextLView: null,\r\n        elementDepthCount: 0,\r\n        currentNamespace: null,\r\n        currentDirectiveIndex: -1,\r\n        bindingRootIndex: -1,\r\n        bindingIndex: -1,\r\n        currentQueryIndex: 0,\r\n        parent: parent,\r\n        child: null,\r\n        inI18n: false,\r\n    };\r\n    parent !== null && (parent.child = lFrame); // link the new LFrame for reuse.\r\n    return lFrame;\r\n}\r\n/**\r\n * A lightweight version of leave which is used with DI.\r\n *\r\n * This function only resets `currentTNode` and `LView` as those are the only properties\r\n * used with DI (`enterDI()`).\r\n *\r\n * NOTE: This function is reexported as `leaveDI`. However `leaveDI` has return type of `void` where\r\n * as `leaveViewLight` has `LFrame`. This is so that `leaveViewLight` can be used in `leaveView`.\r\n */\r\nfunction leaveViewLight() {\r\n    const oldLFrame = instructionState.lFrame;\r\n    instructionState.lFrame = oldLFrame.parent;\r\n    oldLFrame.currentTNode = null;\r\n    oldLFrame.lView = null;\r\n    return oldLFrame;\r\n}\r\n/**\r\n * This is a lightweight version of the `leaveView` which is needed by the DI system.\r\n *\r\n * NOTE: this function is an alias so that we can change the type of the function to have `void`\r\n * return type.\r\n */\r\nconst leaveDI = leaveViewLight;\r\n/**\r\n * Leave the current `LView`\r\n *\r\n * This pops the `LFrame` with the associated `LView` from the stack.\r\n *\r\n * IMPORTANT: We must zero out the `LFrame` values here otherwise they will be retained. This is\r\n * because for performance reasons we don't release `LFrame` but rather keep it for next use.\r\n */\r\nfunction leaveView() {\r\n    const oldLFrame = leaveViewLight();\r\n    oldLFrame.isParent = true;\r\n    oldLFrame.tView = null;\r\n    oldLFrame.selectedIndex = -1;\r\n    oldLFrame.contextLView = null;\r\n    oldLFrame.elementDepthCount = 0;\r\n    oldLFrame.currentDirectiveIndex = -1;\r\n    oldLFrame.currentNamespace = null;\r\n    oldLFrame.bindingRootIndex = -1;\r\n    oldLFrame.bindingIndex = -1;\r\n    oldLFrame.currentQueryIndex = 0;\r\n}\r\nfunction nextContextImpl(level) {\r\n    const contextLView = (instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView));\r\n    return contextLView[CONTEXT];\r\n}\r\n/**\r\n * Gets the currently selected element index.\r\n *\r\n * Used with {@link property} instruction (and more in the future) to identify the index in the\r\n * current `LView` to act on.\r\n */\r\nfunction getSelectedIndex() {\r\n    return instructionState.lFrame.selectedIndex;\r\n}\r\n/**\r\n * Sets the most recent index passed to {@link select}\r\n *\r\n * Used with {@link property} instruction (and more in the future) to identify the index in the\r\n * current `LView` to act on.\r\n *\r\n * (Note that if an \"exit function\" was set earlier (via `setElementExitFn()`) then that will be\r\n * run if and when the provided `index` value is different from the current selected index value.)\r\n */\r\nfunction setSelectedIndex(index) {\r\n    ngDevMode &&\r\n        index !== -1 &&\r\n        assertGreaterThanOrEqual(index, HEADER_OFFSET, 'Index must be past HEADER_OFFSET (or -1).');\r\n    ngDevMode &&\r\n        assertLessThan(index, instructionState.lFrame.lView.length, \"Can't set index passed end of LView\");\r\n    instructionState.lFrame.selectedIndex = index;\r\n}\r\n/**\r\n * Gets the `tNode` that represents currently selected element.\r\n */\r\nfunction getSelectedTNode() {\r\n    const lFrame = instructionState.lFrame;\r\n    return getTNode(lFrame.tView, lFrame.selectedIndex);\r\n}\r\n/**\r\n * Sets the namespace used to create elements to `'http://www.w3.org/2000/svg'` in global state.\r\n *\r\n * @codeGenApi\r\n */\r\nfunction ɵɵnamespaceSVG() {\r\n    instructionState.lFrame.currentNamespace = SVG_NAMESPACE;\r\n}\r\n/**\r\n * Sets the namespace used to create elements to `'http://www.w3.org/1998/MathML/'` in global state.\r\n *\r\n * @codeGenApi\r\n */\r\nfunction ɵɵnamespaceMathML() {\r\n    instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;\r\n}\r\n/**\r\n * Sets the namespace used to create elements to `null`, which forces element creation to use\r\n * `createElement` rather than `createElementNS`.\r\n *\r\n * @codeGenApi\r\n */\r\nfunction ɵɵnamespaceHTML() {\r\n    namespaceHTMLInternal();\r\n}\r\n/**\r\n * Sets the namespace used to create elements to `null`, which forces element creation to use\r\n * `createElement` rather than `createElementNS`.\r\n */\r\nfunction namespaceHTMLInternal() {\r\n    instructionState.lFrame.currentNamespace = null;\r\n}\r\nfunction getNamespace() {\r\n    return instructionState.lFrame.currentNamespace;\r\n}\r\nlet _wasLastNodeCreated = true;\r\n/**\r\n * Retrieves a global flag that indicates whether the most recent DOM node\r\n * was created or hydrated.\r\n */\r\nfunction wasLastNodeCreated() {\r\n    return _wasLastNodeCreated;\r\n}\r\n/**\r\n * Sets a global flag to indicate whether the most recent DOM node\r\n * was created or hydrated.\r\n */\r\nfunction lastNodeWasCreated(flag) {\r\n    _wasLastNodeCreated = flag;\r\n}\r\n/**\r\n * We create an object here because it's possible the DOM Renderer is created\r\n * before the animation removal registry is defined. The object allows us to\r\n * update the instance once the registry is created.\r\n */\r\nlet registry = { elements: undefined };\r\nfunction setAnimationElementRemovalRegistry(value) {\r\n    if (registry.elements === undefined) {\r\n        registry.elements = value;\r\n    }\r\n}\r\nfunction getAnimationElementRemovalRegistry() {\r\n    return registry;\r\n}\r\n\r\n/**\r\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\r\n */\r\nfunction createInjector(defType, parent = null, additionalProviders = null, name) {\r\n    const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);\r\n    injector.resolveInjectorInitializers();\r\n    return injector;\r\n}\r\n/**\r\n * Creates a new injector without eagerly resolving its injector types. Can be used in places\r\n * where resolving the injector types immediately can lead to an infinite loop. The injector types\r\n * should be resolved at a later point by calling `_resolveInjectorDefTypes`.\r\n */\r\nfunction createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = new Set()) {\r\n    const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];\r\n    name = name || (typeof defType === 'object' ? undefined : stringify(defType));\r\n    return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);\r\n}\r\n\r\n/**\r\n * Concrete injectors implement this interface. Injectors are configured\r\n * with [providers](guide/di/dependency-injection-providers) that associate\r\n * dependencies of various types with [injection tokens](guide/di/dependency-injection-providers).\r\n *\r\n * @see [DI Providers](guide/di/dependency-injection-providers).\r\n * @see {@link StaticProvider}\r\n *\r\n * @usageNotes\r\n *\r\n *  The following example creates a service injector instance.\r\n *\r\n * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\r\n *\r\n * ### Usage example\r\n *\r\n * {@example core/di/ts/injector_spec.ts region='Injector'}\r\n *\r\n * `Injector` returns itself when given `Injector` as a token:\r\n *\r\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\r\n *\r\n * @publicApi\r\n */\r\nclass Injector {\r\n    static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\r\n    static NULL = new NullInjector();\r\n    static create(options, parent) {\r\n        if (Array.isArray(options)) {\r\n            return createInjector({ name: '' }, parent, options, '');\r\n        }\r\n        else {\r\n            const name = options.name ?? '';\r\n            return createInjector({ name }, options.parent, options.providers, name);\r\n        }\r\n    }\r\n    /** @nocollapse */\r\n    static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\r\n        token: Injector,\r\n        providedIn: 'any',\r\n        factory: () => ɵɵinject(INJECTOR$1),\r\n    });\r\n    /**\r\n     * @internal\r\n     * @nocollapse\r\n     */\r\n    static __NG_ELEMENT_ID__ = -1 /* InjectorMarkers.Injector */;\r\n}\r\n\r\n/**\r\n * A DI Token representing the main rendering context.\r\n * In a browser and SSR this is the DOM Document.\r\n * When using SSR, that document is created by [Domino](https://github.com/angular/domino).\r\n *\r\n * @publicApi\r\n */\r\nconst DOCUMENT = new InjectionToken(ngDevMode ? 'DocumentToken' : '');\r\n\r\n/**\r\n * `DestroyRef` lets you set callbacks to run for any cleanup or destruction behavior.\r\n * The scope of this destruction depends on where `DestroyRef` is injected. If `DestroyRef`\r\n * is injected in a component or directive, the callbacks run when that component or\r\n * directive is destroyed. Otherwise the callbacks run when a corresponding injector is destroyed.\r\n *\r\n * @publicApi\r\n */\r\nclass DestroyRef {\r\n    /**\r\n     * @internal\r\n     * @nocollapse\r\n     */\r\n    static __NG_ELEMENT_ID__ = injectDestroyRef;\r\n    /**\r\n     * @internal\r\n     * @nocollapse\r\n     */\r\n    static __NG_ENV_ID__ = (injector) => injector;\r\n}\r\nclass NodeInjectorDestroyRef extends DestroyRef {\r\n    _lView;\r\n    constructor(_lView) {\r\n        super();\r\n        this._lView = _lView;\r\n    }\r\n    get destroyed() {\r\n        return isDestroyed(this._lView);\r\n    }\r\n    onDestroy(callback) {\r\n        const lView = this._lView;\r\n        storeLViewOnDestroy(lView, callback);\r\n        return () => removeLViewOnDestroy(lView, callback);\r\n    }\r\n}\r\nfunction injectDestroyRef() {\r\n    return new NodeInjectorDestroyRef(getLView());\r\n}\r\n\r\n/**\r\n * Provides a hook for centralized exception handling.\r\n *\r\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\r\n * intercept error handling, write a custom exception handler that replaces this default as\r\n * appropriate for your app.\r\n *\r\n * @usageNotes\r\n * ### Example\r\n *\r\n * ```ts\r\n * class MyErrorHandler implements ErrorHandler {\r\n *   handleError(error) {\r\n *     // do something with the exception\r\n *   }\r\n * }\r\n *\r\n * // Provide in standalone apps\r\n * bootstrapApplication(AppComponent, {\r\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\r\n * })\r\n *\r\n * // Provide in module-based apps\r\n * @NgModule({\r\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\r\n * })\r\n * class MyModule {}\r\n * ```\r\n *\r\n * @publicApi\r\n */\r\nclass ErrorHandler {\r\n    /**\r\n     * @internal\r\n     */\r\n    _console = console;\r\n    handleError(error) {\r\n        this._console.error('ERROR', error);\r\n    }\r\n}\r\n/**\r\n * `InjectionToken` used to configure how to call the `ErrorHandler`.\r\n */\r\nconst INTERNAL_APPLICATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'internal error handler' : '', {\r\n    providedIn: 'root',\r\n    factory: () => {\r\n        // The user's error handler may depend on things that create a circular dependency\r\n        // so we inject it lazily.\r\n        const injector = inject(EnvironmentInjector);\r\n        let userErrorHandler;\r\n        return (e) => {\r\n            if (injector.destroyed && !userErrorHandler) {\r\n                setTimeout(() => {\r\n                    throw e;\r\n                });\r\n            }\r\n            else {\r\n                userErrorHandler ??= injector.get(ErrorHandler);\r\n                userErrorHandler.handleError(e);\r\n            }\r\n        };\r\n    },\r\n});\r\nconst errorHandlerEnvironmentInitializer = {\r\n    provide: ENVIRONMENT_INITIALIZER,\r\n    useValue: () => void inject(ErrorHandler),\r\n    multi: true,\r\n};\r\nconst globalErrorListeners = new InjectionToken(ngDevMode ? 'GlobalErrorListeners' : '', {\r\n    providedIn: 'root',\r\n    factory: () => {\r\n        if (typeof ngServerMode !== 'undefined' && ngServerMode) {\r\n            return;\r\n        }\r\n        const window = inject(DOCUMENT).defaultView;\r\n        if (!window) {\r\n            return;\r\n        }\r\n        const errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);\r\n        const rejectionListener = (e) => {\r\n            errorHandler(e.reason);\r\n            e.preventDefault();\r\n        };\r\n        const errorListener = (e) => {\r\n            if (e.error) {\r\n                errorHandler(e.error);\r\n            }\r\n            else {\r\n                errorHandler(new Error(ngDevMode\r\n                    ? `An ErrorEvent with no error occurred. See Error.cause for details: ${e.message}`\r\n                    : e.message, { cause: e }));\r\n            }\r\n            e.preventDefault();\r\n        };\r\n        const setupEventListeners = () => {\r\n            window.addEventListener('unhandledrejection', rejectionListener);\r\n            window.addEventListener('error', errorListener);\r\n        };\r\n        // Angular doesn't have to run change detection whenever any asynchronous tasks are invoked in\r\n        // the scope of this functionality.\r\n        if (typeof Zone !== 'undefined') {\r\n            Zone.root.run(setupEventListeners);\r\n        }\r\n        else {\r\n            setupEventListeners();\r\n        }\r\n        inject(DestroyRef).onDestroy(() => {\r\n            window.removeEventListener('error', errorListener);\r\n            window.removeEventListener('unhandledrejection', rejectionListener);\r\n        });\r\n    },\r\n});\r\n/**\r\n * Provides an environment initializer which forwards unhandled errors to the ErrorHandler.\r\n *\r\n * The listeners added are for the window's 'unhandledrejection' and 'error' events.\r\n *\r\n * @publicApi\r\n */\r\nfunction provideBrowserGlobalErrorListeners() {\r\n    return makeEnvironmentProviders([\r\n        provideEnvironmentInitializer(() => void inject(globalErrorListeners)),\r\n    ]);\r\n}\r\n\r\n/**\r\n * Checks if the given `value` is a reactive `Signal`.\r\n *\r\n * @publicApi 17.0\r\n */\r\nfunction isSignal(value) {\r\n    return typeof value === 'function' && value[SIGNAL] !== undefined;\r\n}\r\n\r\n/**\r\n * Utility function used during template type checking to extract the value from a `WritableSignal`.\r\n * @codeGenApi\r\n */\r\nfunction ɵunwrapWritableSignal(value) {\r\n    // Note: the function uses `WRITABLE_SIGNAL` as a brand instead of `WritableSignal<T>`,\r\n    // because the latter incorrectly unwraps non-signal getter functions.\r\n    return null;\r\n}\r\n/**\r\n * Create a `Signal` that can be set or updated directly.\r\n */\r\nfunction signal(initialValue, options) {\r\n    const [get, set, update] = createSignal(initialValue, options?.equal);\r\n    const signalFn = get;\r\n    const node = signalFn[SIGNAL];\r\n    signalFn.set = set;\r\n    signalFn.update = update;\r\n    signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn);\r\n    if (ngDevMode) {\r\n        signalFn.toString = () => `[Signal: ${signalFn()}]`;\r\n        node.debugName = options?.debugName;\r\n    }\r\n    return signalFn;\r\n}\r\nfunction signalAsReadonlyFn() {\r\n    const node = this[SIGNAL];\r\n    if (node.readonlyFn === undefined) {\r\n        const readonlyFn = () => this();\r\n        readonlyFn[SIGNAL] = node;\r\n        node.readonlyFn = readonlyFn;\r\n    }\r\n    return node.readonlyFn;\r\n}\r\n/**\r\n * Checks if the given `value` is a writeable signal.\r\n */\r\nfunction isWritableSignal(value) {\r\n    return isSignal(value) && typeof value.set === 'function';\r\n}\r\n\r\n/**\r\n * Injectable that is notified when an `LView` is made aware of changes to application state.\r\n */\r\nclass ChangeDetectionScheduler {\r\n}\r\n/** Token used to indicate if zoneless was enabled via provideZonelessChangeDetection(). */\r\nconst ZONELESS_ENABLED = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless enabled' : '', { providedIn: 'root', factory: () => false });\r\n/** Token used to indicate `provideZonelessChangeDetection` was used. */\r\nconst PROVIDED_ZONELESS = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'Zoneless provided' : '', { providedIn: 'root', factory: () => false });\r\nconst ZONELESS_SCHEDULER_DISABLED = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'scheduler disabled' : '');\r\n// TODO(atscott): Remove in v19. Scheduler should be done with runOutsideAngular.\r\nconst SCHEDULE_IN_ROOT_ZONE = new InjectionToken(typeof ngDevMode === 'undefined' || ngDevMode ? 'run changes outside zone in root' : '');\r\n\r\n/**\r\n * Asserts that the current stack frame is not within a reactive context. Useful\r\n * to disallow certain code from running inside a reactive context (see {@link /api/core/rxjs-interop/toSignal toSignal})\r\n *\r\n * @param debugFn a reference to the function making the assertion (used for the error message).\r\n *\r\n * @publicApi\r\n */\r\nfunction assertNotInReactiveContext(debugFn, extraContext) {\r\n    // Taking a `Function` instead of a string name here prevents the un-minified name of the function\r\n    // from being retained in the bundle regardless of minification.\r\n    if (getActiveConsumer() !== null) {\r\n        throw new RuntimeError(-602 /* RuntimeErrorCode.ASSERTION_NOT_INSIDE_REACTIVE_CONTEXT */, ngDevMode &&\r\n            `${debugFn.name}() cannot be called from within a reactive context.${extraContext ? ` ${extraContext}` : ''}`);\r\n    }\r\n}\r\n\r\nclass ViewContext {\r\n    view;\r\n    node;\r\n    constructor(view, node) {\r\n        this.view = view;\r\n        this.node = node;\r\n    }\r\n    /**\r\n     * @internal\r\n     * @nocollapse\r\n     */\r\n    static __NG_ELEMENT_ID__ = injectViewContext;\r\n}\r\nfunction injectViewContext() {\r\n    return new ViewContext(getLView(), getCurrentTNode());\r\n}\r\n\r\n/**\r\n * Internal implementation of the pending tasks service.\r\n */\r\nclass PendingTasksInternal {\r\n    taskId = 0;\r\n    pendingTasks = new Set();\r\n    destroyed = false;\r\n    pendingTask = new BehaviorSubject(false);\r\n    get hasPendingTasks() {\r\n        // Accessing the value of a closed `BehaviorSubject` throws an error.\r\n        return this.destroyed ? false : this.pendingTask.value;\r\n    }\r\n    /**\r\n     * In case the service is about to be destroyed, return a self-completing observable.\r\n     * Otherwise, return the observable that emits the current state of pending tasks.\r\n     */\r\n    get hasPendingTasksObservable() {\r\n        if (this.destroyed) {\r\n            // Manually creating the observable pulls less symbols from RxJS than `of(false)`.\r\n            return new Observable((subscriber) => {\r\n                subscriber.next(false);\r\n                subscriber.complete();\r\n            });\r\n        }\r\n        return this.pendingTask;\r\n    }\r\n    add() {\r\n        // Emitting a value to a closed subject throws an error.\r\n        if (!this.hasPendingTasks && !this.destroyed) {\r\n            this.pendingTask.next(true);\r\n        }\r\n        const taskId = this.taskId++;\r\n        this.pendingTasks.add(taskId);\r\n        return taskId;\r\n    }\r\n    has(taskId) {\r\n        return this.pendingTasks.has(taskId);\r\n    }\r\n    remove(taskId) {\r\n        this.pendingTasks.delete(taskId);\r\n        if (this.pendingTasks.size === 0 && this.hasPendingTasks) {\r\n            this.pendingTask.next(false);\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        this.pendingTasks.clear();\r\n        if (this.hasPendingTasks) {\r\n            this.pendingTask.next(false);\r\n        }\r\n        // We call `unsubscribe()` to release observers, as users may forget to\r\n        // unsubscribe manually when subscribing to `isStable`. We do not call\r\n        // `complete()` because it is unsafe; if someone subscribes using the `first`\r\n        // operator and the observable completes before emitting a value,\r\n        // RxJS will throw an error.\r\n        this.destroyed = true;\r\n        this.pendingTask.unsubscribe();\r\n    }\r\n    /** @nocollapse */\r\n    static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\r\n        token: PendingTasksInternal,\r\n        providedIn: 'root',\r\n        factory: () => new PendingTasksInternal(),\r\n    });\r\n}\r\n/**\r\n * Service that keeps track of pending tasks contributing to the stableness of Angular\r\n * application. While several existing Angular services (ex.: `HttpClient`) will internally manage\r\n * tasks influencing stability, this API gives control over stability to library and application\r\n * developers for specific cases not covered by Angular internals.\r\n *\r\n * The concept of stability comes into play in several important scenarios:\r\n * - SSR process needs to wait for the application stability before serializing and sending rendered\r\n * HTML;\r\n * - tests might want to delay assertions until the application becomes stable;\r\n *\r\n * @usageNotes\r\n * ```ts\r\n * const pendingTasks = inject(PendingTasks);\r\n * const taskCleanup = pendingTasks.add();\r\n * // do work that should block application's stability and then:\r\n * taskCleanup();\r\n * ```\r\n *\r\n * @publicApi 20.0\r\n */\r\nclass PendingTasks {\r\n    internalPendingTasks = inject(PendingTasksInternal);\r\n    scheduler = inject(ChangeDetectionScheduler);\r\n    errorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);\r\n    /**\r\n     * Adds a new task that should block application's stability.\r\n     * @returns A cleanup function that removes a task when called.\r\n     */\r\n    add() {\r\n        const taskId = this.internalPendingTasks.add();\r\n        return () => {\r\n            if (!this.internalPendingTasks.has(taskId)) {\r\n                // This pending task has already been cleared.\r\n                return;\r\n            }\r\n            // Notifying the scheduler will hold application stability open until the next tick.\r\n            this.scheduler.notify(11 /* NotificationSource.PendingTaskRemoved */);\r\n            this.internalPendingTasks.remove(taskId);\r\n        };\r\n    }\r\n    /**\r\n     * Runs an asynchronous function and blocks the application's stability until the function completes.\r\n     *\r\n     * ```ts\r\n     * pendingTasks.run(async () => {\r\n     *   const userData = await fetch('/api/user');\r\n     *   this.userData.set(userData);\r\n     * });\r\n     * ```\r\n     *\r\n     * @param fn The asynchronous function to execute\r\n     * @developerPreview 19.0\r\n     */\r\n    run(fn) {\r\n        const removeTask = this.add();\r\n        fn().catch(this.errorHandler).finally(removeTask);\r\n    }\r\n    /** @nocollapse */\r\n    static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\r\n        token: PendingTasks,\r\n        providedIn: 'root',\r\n        factory: () => new PendingTasks(),\r\n    });\r\n}\r\n\r\nfunction noop(...args) {\r\n    // Do nothing.\r\n}\r\n\r\n/**\r\n * A scheduler which manages the execution of effects.\r\n */\r\nclass EffectScheduler {\r\n    /** @nocollapse */\r\n    static ɵprov = /** @pureOrBreakMyCode */ /* @__PURE__ */ ɵɵdefineInjectable({\r\n        token: EffectScheduler,\r\n        providedIn: 'root',\r\n        factory: () => new ZoneAwareEffectScheduler(),\r\n    });\r\n}\r\n/**\r\n * A wrapper around `ZoneAwareQueueingScheduler` that schedules flushing via the microtask queue\r\n * when.\r\n */\r\nclass ZoneAwareEffectScheduler {\r\n    dirtyEffectCount = 0;\r\n    queues = new Map();\r\n    add(handle) {\r\n        this.enqueue(handle);\r\n        this.schedule(handle);\r\n    }\r\n    schedule(handle) {\r\n        if (!handle.dirty) {\r\n            return;\r\n        }\r\n        this.dirtyEffectCount++;\r\n    }\r\n    remove(handle) {\r\n        const zone = handle.zone;\r\n        const queue = this.queues.get(zone);\r\n        if (!queue.has(handle)) {\r\n            return;\r\n        }\r\n        queue.delete(handle);\r\n        if (handle.dirty) {\r\n            this.dirtyEffectCount--;\r\n        }\r\n    }\r\n    enqueue(handle) {\r\n        const zone = handle.zone;\r\n        if (!this.queues.has(zone)) {\r\n            this.queues.set(zone, new Set());\r\n        }\r\n        const queue = this.queues.get(zone);\r\n        if (queue.has(handle)) {\r\n            return;\r\n        }\r\n        queue.add(handle);\r\n    }\r\n    /**\r\n     * Run all scheduled effects.\r\n     *\r\n     * Execution order of effects within the same zone is guaranteed to be FIFO, but there is no\r\n     * ordering guarantee between effects scheduled in different zones.\r\n     */\r\n    flush() {\r\n        while (this.dirtyEffectCount > 0) {\r\n            let ranOneEffect = false;\r\n            for (const [zone, queue] of this.queues) {\r\n                // `zone` here must be defined.\r\n                if (zone === null) {\r\n                    ranOneEffect ||= this.flushQueue(queue);\r\n                }\r\n                else {\r\n                    ranOneEffect ||= zone.run(() => this.flushQueue(queue));\r\n                }\r\n            }\r\n            // Safeguard against infinite looping if somehow our dirty effect count gets out of sync with\r\n            // the dirty flag across all the effects.\r\n            if (!ranOneEffect) {\r\n                this.dirtyEffectCount = 0;\r\n            }\r\n        }\r\n    }\r\n    flushQueue(queue) {\r\n        let ranOneEffect = false;\r\n        for (const handle of queue) {\r\n            if (!handle.dirty) {\r\n                continue;\r\n            }\r\n            this.dirtyEffectCount--;\r\n            ranOneEffect = true;\r\n            // TODO: what happens if this throws an error?\r\n            handle.run();\r\n        }\r\n        return ranOneEffect;\r\n    }\r\n}\r\n\r\nexport { AFTER_RENDER_SEQUENCES_TO_ADD, CHILD_HEAD, CHILD_TAIL, CLEANUP, CONTAINER_HEADER_OFFSET, CONTEXT, ChangeDetectionScheduler, CheckNoChangesMode, DECLARATION_COMPONENT_VIEW, DECLARATION_LCONTAINER, DECLARATION_VIEW, DEHYDRATED_VIEWS, DOCUMENT, DestroyRef, EFFECTS, EFFECTS_TO_SCHEDULE, EMBEDDED_VIEW_INJECTOR, EMPTY_ARRAY, EMPTY_OBJ, ENVIRONMENT, ENVIRONMENT_INITIALIZER, EffectScheduler, EnvironmentInjector, ErrorHandler, FLAGS, HEADER_OFFSET, HOST, HYDRATION, ID, INJECTOR$1 as INJECTOR, INJECTOR as INJECTOR$1, INJECTOR_DEF_TYPES, INJECTOR_SCOPE, INTERNAL_APPLICATION_ERROR_HANDLER, InjectionToken, Injector, MATH_ML_NAMESPACE, MOVED_VIEWS, NATIVE, NEXT, NG_COMP_DEF, NG_DIR_DEF, NG_ELEMENT_ID, NG_FACTORY_DEF, NG_INJ_DEF, NG_MOD_DEF, NG_PIPE_DEF, NG_PROV_DEF, NodeInjectorDestroyRef, NullInjector, ON_DESTROY_HOOKS, PARENT, PREORDER_HOOK_FLAGS, PROVIDED_ZONELESS, PendingTasks, PendingTasksInternal, QUERIES, R3Injector, REACTIVE_TEMPLATE_CONSUMER, RENDERER, RuntimeError, SCHEDULE_IN_ROOT_ZONE, SVG_NAMESPACE, TVIEW, T_HOST, VIEW_REFS, ViewContext, XSS_SECURITY_URL, ZONELESS_ENABLED, ZONELESS_SCHEDULER_DISABLED, _global, addToArray, arrayEquals, arrayInsert2, arraySplice, assertComponentType, assertDefined, assertDirectiveDef, assertDomNode, assertElement, assertEqual, assertFirstCreatePass, assertFirstUpdatePass, assertFunction, assertGreaterThan, assertGreaterThanOrEqual, assertHasParent, assertInInjectionContext, assertIndexInDeclRange, assertIndexInExpandoRange, assertIndexInRange, assertInjectImplementationNotEqual, assertLContainer, assertLView, assertLessThan, assertNgModuleType, assertNodeInjector, assertNotDefined, assertNotEqual, assertNotInReactiveContext, assertNotReactive, assertNotSame, assertNumber, assertNumberInRange, assertOneOf, assertParentView, assertProjectionSlots, assertSame, assertString, assertTIcu, assertTNode, assertTNodeCreationIndex, assertTNodeForLView, assertTNodeForTView, attachInjectFlag, concatStringsWithSpace, convertToBitFlags, createInjector, createInjectorWithoutInjectorInstances, cyclicDependencyError, cyclicDependencyErrorWithDetails, debugStringifyTypeForError, decreaseElementDepthCount, deepForEach, defineInjectable, emitEffectCreatedEvent, emitInjectEvent, emitInjectorToCreateInstanceEvent, emitInstanceCreatedByInjectorEvent, emitProviderConfiguredEvent, enterDI, enterSkipHydrationBlock, enterView, errorHandlerEnvironmentInitializer, fillProperties, flatten, formatRuntimeError, forwardRef, getAnimationElementRemovalRegistry, getBindingIndex, getBindingRoot, getBindingsEnabled, getClosureSafeProperty, getComponentDef, getComponentLViewByIndex, getConstant, getContextLView, getCurrentDirectiveDef, getCurrentDirectiveIndex, getCurrentParentTNode, getCurrentQueryIndex, getCurrentTNode, getCurrentTNodePlaceholderOk, getDirectiveDef, getDirectiveDefOrThrow, getElementDepthCount, getFactoryDef, getInjectableDef, getInjectorDef, getLView, getLViewParent, getNamespace, getNativeByIndex, getNativeByTNode, getNativeByTNodeOrNull, getNgModuleDef, getNgModuleDefOrThrow, getNullInjector, getOrCreateLViewCleanup, getOrCreateTViewCleanup, getPipeDef, getSelectedIndex, getSelectedTNode, getTNode, getTView, hasI18n, importProvidersFrom, increaseElementDepthCount, incrementBindingIndex, initNgDevMode, inject, injectRootLimpMode, internalImportProvidersFrom, isClassProvider, isComponentDef, isComponentHost, isContentQueryHost, isCreationMode, isCurrentTNodeParent, isDestroyed, isDirectiveHost, isEnvironmentProviders, isExhaustiveCheckNoChanges, isForwardRef, isInCheckNoChangesMode, isInI18nBlock, isInInjectionContext, isInSkipHydrationBlock, isInjectable, isLContainer, isLView, isProjectionTNode, isRefreshingViews, isRootView, isSignal, isSkipHydrationRootTNode, isStandalone, isTypeProvider, isWritableSignal, keyValueArrayGet, keyValueArrayIndexOf, keyValueArraySet, lastNodeWasCreated, leaveDI, leaveSkipHydrationBlock, leaveView, load, makeEnvironmentProviders, markAncestorsForTraversal, markViewForRefresh, newArray, nextBindingIndex, nextContextImpl, noop, provideBrowserGlobalErrorListeners, provideEnvironmentInitializer, providerToFactory, removeFromArray, removeLViewOnDestroy, renderStringify, requiresRefreshOrTraversal, resetPreOrderHookFlags, resolveForwardRef, runInInjectionContext, runInInjectorProfilerContext, setAnimationElementRemovalRegistry, setBindingIndex, setBindingRootForHostBindings, setCurrentDirectiveIndex, setCurrentQueryIndex, setCurrentTNode, setCurrentTNodeAsNotParent, setInI18nBlock, setInjectImplementation, setInjectorProfiler, setInjectorProfilerContext, setIsInCheckNoChangesMode, setIsRefreshingViews, setSelectedIndex, signal, signalAsReadonlyFn, store, storeCleanupWithContext, storeLViewOnDestroy, stringify, stringifyForError, throwError, throwProviderNotFoundError, truncateMiddle, unwrapLView, unwrapRNode, updateAncestorTraversalFlagsOnAttach, viewAttachedToChangeDetector, viewAttachedToContainer, walkProviderTree, walkUpViews, wasLastNodeCreated, ɵunwrapWritableSignal, ɵɵdefineInjectable, ɵɵdefineInjector, ɵɵdisableBindings, ɵɵenableBindings, ɵɵinject, ɵɵinvalidFactoryDep, ɵɵnamespaceHTML, ɵɵnamespaceMathML, ɵɵnamespaceSVG, ɵɵresetView, ɵɵrestoreView };\r\n\r\n", "/**\r\n * @license Angular v20.2.1\r\n * (c) 2010-2025 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { inject, ErrorHandler, DestroyRef, RuntimeError, formatRuntimeError, assertNotInReactiveContext, assertInInjectionContext, Injector, ViewContext, ChangeDetectionScheduler, EffectScheduler, setInjectorProfilerContext, emitEffectCreatedEvent, EFFECTS, NodeInjectorDestroyRef, FLAGS, markAncestorsForTraversal, noop, setIsRefreshingViews, signalAsReadonlyFn, PendingTasks, signal } from './root_effect_scheduler.mjs';\r\nimport { setActiveConsumer, createComputed, SIGNAL, consumerDestroy, REACTIVE_NODE, isInNotificationPhase, consumerPollProducersForChange, consumerBeforeComputation, consumerAfterComputation } from './signal.mjs';\r\nimport { untracked as untracked$1, createLinkedSignal, linkedSignalSetFn, linkedSignalUpdateFn } from './untracked.mjs';\r\n\r\n/**\r\n * An `OutputEmitterRef` is created by the `output()` function and can be\r\n * used to emit values to consumers of your directive or component.\r\n *\r\n * Consumers of your directive/component can bind to the output and\r\n * subscribe to changes via the bound event syntax. For example:\r\n *\r\n * ```html\r\n * <my-comp (valueChange)=\"processNewValue($event)\" />\r\n * ```\r\n *\r\n * @publicAPI\r\n */\r\nclass OutputEmitterRef {\r\n    destroyed = false;\r\n    listeners = null;\r\n    errorHandler = inject(ErrorHandler, { optional: true });\r\n    /** @internal */\r\n    destroyRef = inject(DestroyRef);\r\n    constructor() {\r\n        // Clean-up all listeners and mark as destroyed upon destroy.\r\n        this.destroyRef.onDestroy(() => {\r\n            this.destroyed = true;\r\n            this.listeners = null;\r\n        });\r\n    }\r\n    subscribe(callback) {\r\n        if (this.destroyed) {\r\n            throw new RuntimeError(953 /* RuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\r\n                'Unexpected subscription to destroyed `OutputRef`. ' +\r\n                    'The owning directive/component is destroyed.');\r\n        }\r\n        (this.listeners ??= []).push(callback);\r\n        return {\r\n            unsubscribe: () => {\r\n                const idx = this.listeners?.indexOf(callback);\r\n                if (idx !== undefined && idx !== -1) {\r\n                    this.listeners?.splice(idx, 1);\r\n                }\r\n            },\r\n        };\r\n    }\r\n    /** Emits a new value to the output. */\r\n    emit(value) {\r\n        if (this.destroyed) {\r\n            console.warn(formatRuntimeError(953 /* RuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\r\n                'Unexpected emit for destroyed `OutputRef`. ' +\r\n                    'The owning directive/component is destroyed.'));\r\n            return;\r\n        }\r\n        if (this.listeners === null) {\r\n            return;\r\n        }\r\n        const previousConsumer = setActiveConsumer(null);\r\n        try {\r\n            for (const listenerFn of this.listeners) {\r\n                try {\r\n                    listenerFn(value);\r\n                }\r\n                catch (err) {\r\n                    this.errorHandler?.handleError(err);\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            setActiveConsumer(previousConsumer);\r\n        }\r\n    }\r\n}\r\n/** Gets the owning `DestroyRef` for the given output. */\r\nfunction getOutputDestroyRef(ref) {\r\n    return ref.destroyRef;\r\n}\r\n\r\n/**\r\n * Execute an arbitrary function in a non-reactive (non-tracking) context. The executed function\r\n * can, optionally, return a value.\r\n */\r\nfunction untracked(nonReactiveReadsFn) {\r\n    return untracked$1(nonReactiveReadsFn);\r\n}\r\n\r\n/**\r\n * Create a computed `Signal` which derives a reactive value from an expression.\r\n */\r\nfunction computed(computation, options) {\r\n    const getter = createComputed(computation, options?.equal);\r\n    if (ngDevMode) {\r\n        getter.toString = () => `[Computed: ${getter()}]`;\r\n        getter[SIGNAL].debugName = options?.debugName;\r\n    }\r\n    return getter;\r\n}\r\n\r\nclass EffectRefImpl {\r\n    [SIGNAL];\r\n    constructor(node) {\r\n        this[SIGNAL] = node;\r\n    }\r\n    destroy() {\r\n        this[SIGNAL].destroy();\r\n    }\r\n}\r\n/**\r\n * Registers an \"effect\" that will be scheduled & executed whenever the signals that it reads\r\n * changes.\r\n *\r\n * Angular has two different kinds of effect: component effects and root effects. Component effects\r\n * are created when `effect()` is called from a component, directive, or within a service of a\r\n * component/directive. Root effects are created when `effect()` is called from outside the\r\n * component tree, such as in a root service.\r\n *\r\n * The two effect types differ in their timing. Component effects run as a component lifecycle\r\n * event during Angular's synchronization (change detection) process, and can safely read input\r\n * signals or create/destroy views that depend on component state. Root effects run as microtasks\r\n * and have no connection to the component tree or change detection.\r\n *\r\n * `effect()` must be run in injection context, unless the `injector` option is manually specified.\r\n *\r\n * @publicApi 20.0\r\n */\r\nfunction effect(effectFn, options) {\r\n    ngDevMode &&\r\n        assertNotInReactiveContext(effect, 'Call `effect` outside of a reactive context. For example, schedule the ' +\r\n            'effect inside the component constructor.');\r\n    if (ngDevMode && !options?.injector) {\r\n        assertInInjectionContext(effect);\r\n    }\r\n    if (ngDevMode && options?.allowSignalWrites !== undefined) {\r\n        console.warn(`The 'allowSignalWrites' flag is deprecated and no longer impacts effect() (writes are always allowed)`);\r\n    }\r\n    const injector = options?.injector ?? inject(Injector);\r\n    let destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;\r\n    let node;\r\n    const viewContext = injector.get(ViewContext, null, { optional: true });\r\n    const notifier = injector.get(ChangeDetectionScheduler);\r\n    if (viewContext !== null) {\r\n        // This effect was created in the context of a view, and will be associated with the view.\r\n        node = createViewEffect(viewContext.view, notifier, effectFn);\r\n        if (destroyRef instanceof NodeInjectorDestroyRef && destroyRef._lView === viewContext.view) {\r\n            // The effect is being created in the same view as the `DestroyRef` references, so it will be\r\n            // automatically destroyed without the need for an explicit `DestroyRef` registration.\r\n            destroyRef = null;\r\n        }\r\n    }\r\n    else {\r\n        // This effect was created outside the context of a view, and will be scheduled independently.\r\n        node = createRootEffect(effectFn, injector.get(EffectScheduler), notifier);\r\n    }\r\n    node.injector = injector;\r\n    if (destroyRef !== null) {\r\n        // If we need to register for cleanup, do that here.\r\n        node.onDestroyFn = destroyRef.onDestroy(() => node.destroy());\r\n    }\r\n    const effectRef = new EffectRefImpl(node);\r\n    if (ngDevMode) {\r\n        node.debugName = options?.debugName ?? '';\r\n        const prevInjectorProfilerContext = setInjectorProfilerContext({ injector, token: null });\r\n        try {\r\n            emitEffectCreatedEvent(effectRef);\r\n        }\r\n        finally {\r\n            setInjectorProfilerContext(prevInjectorProfilerContext);\r\n        }\r\n    }\r\n    return effectRef;\r\n}\r\nconst BASE_EFFECT_NODE = \r\n/* @__PURE__ */ (() => ({\r\n    ...REACTIVE_NODE,\r\n    consumerIsAlwaysLive: true,\r\n    consumerAllowSignalWrites: true,\r\n    dirty: true,\r\n    hasRun: false,\r\n    cleanupFns: undefined,\r\n    zone: null,\r\n    kind: 'effect',\r\n    onDestroyFn: noop,\r\n    run() {\r\n        this.dirty = false;\r\n        if (ngDevMode && isInNotificationPhase()) {\r\n            throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\r\n        }\r\n        if (this.hasRun && !consumerPollProducersForChange(this)) {\r\n            return;\r\n        }\r\n        this.hasRun = true;\r\n        const registerCleanupFn = (cleanupFn) => (this.cleanupFns ??= []).push(cleanupFn);\r\n        const prevNode = consumerBeforeComputation(this);\r\n        // We clear `setIsRefreshingViews` so that `markForCheck()` within the body of an effect will\r\n        // cause CD to reach the component in question.\r\n        const prevRefreshingViews = setIsRefreshingViews(false);\r\n        try {\r\n            this.maybeCleanup();\r\n            this.fn(registerCleanupFn);\r\n        }\r\n        finally {\r\n            setIsRefreshingViews(prevRefreshingViews);\r\n            consumerAfterComputation(this, prevNode);\r\n        }\r\n    },\r\n    maybeCleanup() {\r\n        if (!this.cleanupFns?.length) {\r\n            return;\r\n        }\r\n        const prevConsumer = setActiveConsumer(null);\r\n        try {\r\n            // Attempt to run the cleanup functions. Regardless of failure or success, we consider\r\n            // cleanup \"completed\" and clear the list for the next run of the effect. Note that an error\r\n            // from the cleanup function will still crash the current run of the effect.\r\n            while (this.cleanupFns.length) {\r\n                this.cleanupFns.pop()();\r\n            }\r\n        }\r\n        finally {\r\n            this.cleanupFns = [];\r\n            setActiveConsumer(prevConsumer);\r\n        }\r\n    },\r\n}))();\r\nconst ROOT_EFFECT_NODE = \r\n/* @__PURE__ */ (() => ({\r\n    ...BASE_EFFECT_NODE,\r\n    consumerMarkedDirty() {\r\n        this.scheduler.schedule(this);\r\n        this.notifier.notify(12 /* NotificationSource.RootEffect */);\r\n    },\r\n    destroy() {\r\n        consumerDestroy(this);\r\n        this.onDestroyFn();\r\n        this.maybeCleanup();\r\n        this.scheduler.remove(this);\r\n    },\r\n}))();\r\nconst VIEW_EFFECT_NODE = \r\n/* @__PURE__ */ (() => ({\r\n    ...BASE_EFFECT_NODE,\r\n    consumerMarkedDirty() {\r\n        this.view[FLAGS] |= 8192 /* LViewFlags.HasChildViewsToRefresh */;\r\n        markAncestorsForTraversal(this.view);\r\n        this.notifier.notify(13 /* NotificationSource.ViewEffect */);\r\n    },\r\n    destroy() {\r\n        consumerDestroy(this);\r\n        this.onDestroyFn();\r\n        this.maybeCleanup();\r\n        this.view[EFFECTS]?.delete(this);\r\n    },\r\n}))();\r\nfunction createViewEffect(view, notifier, fn) {\r\n    const node = Object.create(VIEW_EFFECT_NODE);\r\n    node.view = view;\r\n    node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\r\n    node.notifier = notifier;\r\n    node.fn = fn;\r\n    view[EFFECTS] ??= new Set();\r\n    view[EFFECTS].add(node);\r\n    node.consumerMarkedDirty(node);\r\n    return node;\r\n}\r\nfunction createRootEffect(fn, scheduler, notifier) {\r\n    const node = Object.create(ROOT_EFFECT_NODE);\r\n    node.fn = fn;\r\n    node.scheduler = scheduler;\r\n    node.notifier = notifier;\r\n    node.zone = typeof Zone !== 'undefined' ? Zone.current : null;\r\n    node.scheduler.add(node);\r\n    node.notifier.notify(12 /* NotificationSource.RootEffect */);\r\n    return node;\r\n}\r\n\r\nconst identityFn = (v) => v;\r\nfunction linkedSignal(optionsOrComputation, options) {\r\n    if (typeof optionsOrComputation === 'function') {\r\n        const getter = createLinkedSignal(optionsOrComputation, (identityFn), options?.equal);\r\n        return upgradeLinkedSignalGetter(getter);\r\n    }\r\n    else {\r\n        const getter = createLinkedSignal(optionsOrComputation.source, optionsOrComputation.computation, optionsOrComputation.equal);\r\n        return upgradeLinkedSignalGetter(getter);\r\n    }\r\n}\r\nfunction upgradeLinkedSignalGetter(getter) {\r\n    if (ngDevMode) {\r\n        getter.toString = () => `[LinkedSignal: ${getter()}]`;\r\n    }\r\n    const node = getter[SIGNAL];\r\n    const upgradedGetter = getter;\r\n    upgradedGetter.set = (newValue) => linkedSignalSetFn(node, newValue);\r\n    upgradedGetter.update = (updateFn) => linkedSignalUpdateFn(node, updateFn);\r\n    upgradedGetter.asReadonly = signalAsReadonlyFn.bind(getter);\r\n    return upgradedGetter;\r\n}\r\n\r\n/**\r\n * Whether a `Resource.value()` should throw an error when the resource is in the error state.\r\n *\r\n * This internal flag is being used to gradually roll out this behavior.\r\n */\r\nlet RESOURCE_VALUE_THROWS_ERRORS_DEFAULT = true;\r\nfunction resource(options) {\r\n    if (ngDevMode && !options?.injector) {\r\n        assertInInjectionContext(resource);\r\n    }\r\n    const oldNameForParams = options.request;\r\n    const params = (options.params ?? oldNameForParams ?? (() => null));\r\n    return new ResourceImpl(params, getLoader(options), options.defaultValue, options.equal ? wrapEqualityFn(options.equal) : undefined, options.injector ?? inject(Injector), RESOURCE_VALUE_THROWS_ERRORS_DEFAULT);\r\n}\r\n/**\r\n * Base class which implements `.value` as a `WritableSignal` by delegating `.set` and `.update`.\r\n */\r\nclass BaseWritableResource {\r\n    value;\r\n    constructor(value) {\r\n        this.value = value;\r\n        this.value.set = this.set.bind(this);\r\n        this.value.update = this.update.bind(this);\r\n        this.value.asReadonly = signalAsReadonlyFn;\r\n    }\r\n    isError = computed(() => this.status() === 'error');\r\n    update(updateFn) {\r\n        this.set(updateFn(untracked(this.value)));\r\n    }\r\n    isLoading = computed(() => this.status() === 'loading' || this.status() === 'reloading');\r\n    // Use a computed here to avoid triggering reactive consumers if the value changes while staying\r\n    // either defined or undefined.\r\n    isValueDefined = computed(() => {\r\n        // Check if it's in an error state first to prevent the error from bubbling up.\r\n        if (this.isError()) {\r\n            return false;\r\n        }\r\n        return this.value() !== undefined;\r\n    });\r\n    hasValue() {\r\n        return this.isValueDefined();\r\n    }\r\n    asReadonly() {\r\n        return this;\r\n    }\r\n}\r\n/**\r\n * Implementation for `resource()` which uses a `linkedSignal` to manage the resource's state.\r\n */\r\nclass ResourceImpl extends BaseWritableResource {\r\n    loaderFn;\r\n    equal;\r\n    pendingTasks;\r\n    /**\r\n     * The current state of the resource. Status, value, and error are derived from this.\r\n     */\r\n    state;\r\n    /**\r\n     * Combines the current request with a reload counter which allows the resource to be reloaded on\r\n     * imperative command.\r\n     */\r\n    extRequest;\r\n    effectRef;\r\n    pendingController;\r\n    resolvePendingTask = undefined;\r\n    destroyed = false;\r\n    unregisterOnDestroy;\r\n    constructor(request, loaderFn, defaultValue, equal, injector, throwErrorsFromValue = RESOURCE_VALUE_THROWS_ERRORS_DEFAULT) {\r\n        super(\r\n        // Feed a computed signal for the value to `BaseWritableResource`, which will upgrade it to a\r\n        // `WritableSignal` that delegates to `ResourceImpl.set`.\r\n        computed(() => {\r\n            const streamValue = this.state().stream?.();\r\n            if (!streamValue) {\r\n                return defaultValue;\r\n            }\r\n            // Prevents `hasValue()` from throwing an error when a reload happened in the error state\r\n            if (this.state().status === 'loading' && this.error()) {\r\n                return defaultValue;\r\n            }\r\n            if (!isResolved(streamValue)) {\r\n                if (throwErrorsFromValue) {\r\n                    throw new ResourceValueError(this.error());\r\n                }\r\n                else {\r\n                    return defaultValue;\r\n                }\r\n            }\r\n            return streamValue.value;\r\n        }, { equal }));\r\n        this.loaderFn = loaderFn;\r\n        this.equal = equal;\r\n        // Extend `request()` to include a writable reload signal.\r\n        this.extRequest = linkedSignal({\r\n            source: request,\r\n            computation: (request) => ({ request, reload: 0 }),\r\n        });\r\n        // The main resource state is managed in a `linkedSignal`, which allows the resource to change\r\n        // state instantaneously when the request signal changes.\r\n        this.state = linkedSignal({\r\n            // Whenever the request changes,\r\n            source: this.extRequest,\r\n            // Compute the state of the resource given a change in status.\r\n            computation: (extRequest, previous) => {\r\n                const status = extRequest.request === undefined ? 'idle' : 'loading';\r\n                if (!previous) {\r\n                    return {\r\n                        extRequest,\r\n                        status,\r\n                        previousStatus: 'idle',\r\n                        stream: undefined,\r\n                    };\r\n                }\r\n                else {\r\n                    return {\r\n                        extRequest,\r\n                        status,\r\n                        previousStatus: projectStatusOfState(previous.value),\r\n                        // If the request hasn't changed, keep the previous stream.\r\n                        stream: previous.value.extRequest.request === extRequest.request\r\n                            ? previous.value.stream\r\n                            : undefined,\r\n                    };\r\n                }\r\n            },\r\n        });\r\n        this.effectRef = effect(this.loadEffect.bind(this), {\r\n            injector,\r\n            manualCleanup: true,\r\n        });\r\n        this.pendingTasks = injector.get(PendingTasks);\r\n        // Cancel any pending request when the resource itself is destroyed.\r\n        this.unregisterOnDestroy = injector.get(DestroyRef).onDestroy(() => this.destroy());\r\n    }\r\n    status = computed(() => projectStatusOfState(this.state()));\r\n    error = computed(() => {\r\n        const stream = this.state().stream?.();\r\n        return stream && !isResolved(stream) ? stream.error : undefined;\r\n    });\r\n    /**\r\n     * Called either directly via `WritableResource.set` or via `.value.set()`.\r\n     */\r\n    set(value) {\r\n        if (this.destroyed) {\r\n            return;\r\n        }\r\n        const error = untracked(this.error);\r\n        const state = untracked(this.state);\r\n        if (!error) {\r\n            const current = untracked(this.value);\r\n            if (state.status === 'local' &&\r\n                (this.equal ? this.equal(current, value) : current === value)) {\r\n                return;\r\n            }\r\n        }\r\n        // Enter Local state with the user-defined value.\r\n        this.state.set({\r\n            extRequest: state.extRequest,\r\n            status: 'local',\r\n            previousStatus: 'local',\r\n            stream: signal({ value }),\r\n        });\r\n        // We're departing from whatever state the resource was in previously, so cancel any in-progress\r\n        // loading operations.\r\n        this.abortInProgressLoad();\r\n    }\r\n    reload() {\r\n        // We don't want to restart in-progress loads.\r\n        const { status } = untracked(this.state);\r\n        if (status === 'idle' || status === 'loading') {\r\n            return false;\r\n        }\r\n        // Increment the request reload to trigger the `state` linked signal to switch us to `Reload`\r\n        this.extRequest.update(({ request, reload }) => ({ request, reload: reload + 1 }));\r\n        return true;\r\n    }\r\n    destroy() {\r\n        this.destroyed = true;\r\n        this.unregisterOnDestroy();\r\n        this.effectRef.destroy();\r\n        this.abortInProgressLoad();\r\n        // Destroyed resources enter Idle state.\r\n        this.state.set({\r\n            extRequest: { request: undefined, reload: 0 },\r\n            status: 'idle',\r\n            previousStatus: 'idle',\r\n            stream: undefined,\r\n        });\r\n    }\r\n    async loadEffect() {\r\n        const extRequest = this.extRequest();\r\n        // Capture the previous status before any state transitions. Note that this is `untracked` since\r\n        // we do not want the effect to depend on the state of the resource, only on the request.\r\n        const { status: currentStatus, previousStatus } = untracked(this.state);\r\n        if (extRequest.request === undefined) {\r\n            // Nothing to load (and we should already be in a non-loading state).\r\n            return;\r\n        }\r\n        else if (currentStatus !== 'loading') {\r\n            // We're not in a loading or reloading state, so this loading request is stale.\r\n            return;\r\n        }\r\n        // Cancel any previous loading attempts.\r\n        this.abortInProgressLoad();\r\n        // Capturing _this_ load's pending task in a local variable is important here. We may attempt to\r\n        // resolve it twice:\r\n        //\r\n        //  1. when the loading function promise resolves/rejects\r\n        //  2. when cancelling the loading operation\r\n        //\r\n        // After the loading operation is cancelled, `this.resolvePendingTask` no longer represents this\r\n        // particular task, but this `await` may eventually resolve/reject. Thus, when we cancel in\r\n        // response to (1) below, we need to cancel the locally saved task.\r\n        let resolvePendingTask = (this.resolvePendingTask =\r\n            this.pendingTasks.add());\r\n        const { signal: abortSignal } = (this.pendingController = new AbortController());\r\n        try {\r\n            // The actual loading is run through `untracked` - only the request side of `resource` is\r\n            // reactive. This avoids any confusion with signals tracking or not tracking depending on\r\n            // which side of the `await` they are.\r\n            const stream = await untracked(() => {\r\n                return this.loaderFn({\r\n                    params: extRequest.request,\r\n                    // TODO(alxhub): cleanup after g3 removal of `request` alias.\r\n                    request: extRequest.request,\r\n                    abortSignal,\r\n                    previous: {\r\n                        status: previousStatus,\r\n                    },\r\n                });\r\n            });\r\n            // If this request has been aborted, or the current request no longer\r\n            // matches this load, then we should ignore this resolution.\r\n            if (abortSignal.aborted || untracked(this.extRequest) !== extRequest) {\r\n                return;\r\n            }\r\n            this.state.set({\r\n                extRequest,\r\n                status: 'resolved',\r\n                previousStatus: 'resolved',\r\n                stream,\r\n            });\r\n        }\r\n        catch (err) {\r\n            if (abortSignal.aborted || untracked(this.extRequest) !== extRequest) {\r\n                return;\r\n            }\r\n            this.state.set({\r\n                extRequest,\r\n                status: 'resolved',\r\n                previousStatus: 'error',\r\n                stream: signal({ error: encapsulateResourceError(err) }),\r\n            });\r\n        }\r\n        finally {\r\n            // Resolve the pending task now that the resource has a value.\r\n            resolvePendingTask?.();\r\n            resolvePendingTask = undefined;\r\n        }\r\n    }\r\n    abortInProgressLoad() {\r\n        untracked(() => this.pendingController?.abort());\r\n        this.pendingController = undefined;\r\n        // Once the load is aborted, we no longer want to block stability on its resolution.\r\n        this.resolvePendingTask?.();\r\n        this.resolvePendingTask = undefined;\r\n    }\r\n}\r\n/**\r\n * Wraps an equality function to handle either value being `undefined`.\r\n */\r\nfunction wrapEqualityFn(equal) {\r\n    return (a, b) => (a === undefined || b === undefined ? a === b : equal(a, b));\r\n}\r\nfunction getLoader(options) {\r\n    if (isStreamingResourceOptions(options)) {\r\n        return options.stream;\r\n    }\r\n    return async (params) => {\r\n        try {\r\n            return signal({ value: await options.loader(params) });\r\n        }\r\n        catch (err) {\r\n            return signal({ error: encapsulateResourceError(err) });\r\n        }\r\n    };\r\n}\r\nfunction isStreamingResourceOptions(options) {\r\n    return !!options.stream;\r\n}\r\n/**\r\n * Project from a state with `ResourceInternalStatus` to the user-facing `ResourceStatus`\r\n */\r\nfunction projectStatusOfState(state) {\r\n    switch (state.status) {\r\n        case 'loading':\r\n            return state.extRequest.reload === 0 ? 'loading' : 'reloading';\r\n        case 'resolved':\r\n            return isResolved(state.stream()) ? 'resolved' : 'error';\r\n        default:\r\n            return state.status;\r\n    }\r\n}\r\nfunction isResolved(state) {\r\n    return state.error === undefined;\r\n}\r\nfunction encapsulateResourceError(error) {\r\n    if (error instanceof Error) {\r\n        return error;\r\n    }\r\n    return new ResourceWrappedError(error);\r\n}\r\nclass ResourceValueError extends Error {\r\n    constructor(error) {\r\n        super(ngDevMode\r\n            ? `Resource is currently in an error state (see Error.cause for details): ${error.message}`\r\n            : error.message, { cause: error });\r\n    }\r\n}\r\nclass ResourceWrappedError extends Error {\r\n    constructor(error) {\r\n        super(ngDevMode\r\n            ? `Resource returned an error that's not an Error instance: ${String(error)}. Check this error's .cause for the actual error.`\r\n            : String(error), { cause: error });\r\n    }\r\n}\r\n\r\nexport { OutputEmitterRef, ResourceImpl, computed, effect, encapsulateResourceError, getOutputDestroyRef, linkedSignal, resource, untracked };\r\n\r\n"],
  "mappings": "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",
  "names": ["link", "computed", "injectorProfiler", "effect", "inject", "CheckNoChangesMode", "isInI18nBlock", "inject", "untracked", "request"]
}
